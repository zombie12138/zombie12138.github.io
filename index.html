<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zombie12138.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="zombie&#39;s">
<meta property="og:url" content="https://zombie12138.github.io/index.html">
<meta property="og:site_name" content="zombie&#39;s">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="zombie12138">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://zombie12138.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>zombie's</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">zombie's</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zombie12138.github.io/2023/%E4%B8%8D%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84Vector-resize-%E5%8A%AB%E6%8C%81%E7%B1%BB%E7%A7%81%E6%9C%89%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-Folly%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zombie12138">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zombie's">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/%E4%B8%8D%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84Vector-resize-%E5%8A%AB%E6%8C%81%E7%B1%BB%E7%A7%81%E6%9C%89%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-Folly%E5%BA%93/" class="post-title-link" itemprop="url">不调用构造函数的Vector resize | 劫持类私有成员函数 | Folly库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-20 21:04:54" itemprop="dateCreated datePublished" datetime="2023-09-20T21:04:54+08:00">2023-09-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-13 17:12:50" itemprop="dateModified" datetime="2023-10-13T17:12:50+08:00">2023-10-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近遇到一个有趣的问题, 如何不初始化地对一个vector进行resize? </p>
<p>实验在2Socket * 鲲鹏920-Server(一共128C 256G 4NUMA)进行, 操作系统<code>CentOS Linux release 7.9.2009 (AltArch)</code>, 内核版本<code>4.14.0-115.el7a.0.1.aarch64</code>, GCC 7.5.0, 开启了Page Size(65536, 64KB), (GNU libc) 2.17</p>
<h2 id="vector中resize的初始化问题"><a href="#vector中resize的初始化问题" class="headerlink" title="vector中resize的初始化问题"></a>vector中resize的初始化问题</h2><h3 id="为什么要不初始化"><a href="#为什么要不初始化" class="headerlink" title="为什么要不初始化?"></a>为什么要不初始化?</h3><p>之前在<a href="/2023/NUMA%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8CFirstTouch/" title="[NUMA和FirstTouch的文章]">[NUMA和FirstTouch的文章]</a>里面提到, 对于一个数组, 我们可能想不让他初始化, 在First Touch之后再去分配具体的内存位置, 尽管这个可能不那么可靠… </p>
<p>对于Vetor, 默认情况会进行初始化. 使用指定大小的初始化函数和resize都会有初始化操作, 并且会提前触发First Touch, 是内存全都分布在主节点的空间.</p>
<p>下面这个程序, 现在主线程0 Node上触碰512页面的位置, 之后用Node 3上的线程触碰所有的页面, First Touch会分配在第一次触碰页面的Node上, 也就是说, 如果vector没有初始化, 只有512页面会被触碰</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #define _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numaif.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USE_VECTOR_RESERVE</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">long</span> size = <span class="number">65536</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bind_thread_to_core</span><span class="params">(<span class="type">int</span> core_id)</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpuset;</span><br><span class="line"></span><br><span class="line">    thread = <span class="built_in">pthread_self</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CPU_ZERO</span>(&amp;cpuset);</span><br><span class="line">    <span class="built_in">CPU_SET</span>(core_id, &amp;cpuset);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sched_setaffinity</span>(<span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">cpu_set_t</span>), &amp;cpuset);</span><br><span class="line">    <span class="comment">//pthread_setaffinity_np(thread, sizeof(cpu_set_t), &amp;cpuset);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">init</span><span class="params">(<span class="type">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pid = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">long</span>&gt;(arg);</span><br><span class="line">    <span class="built_in">bind_thread_to_core</span>(pid);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">long</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        a[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">bind_thread_to_core</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_NEW</span></span><br><span class="line">    a = <span class="keyword">new</span> <span class="type">char</span>[size];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_MALLOC</span></span><br><span class="line">    a = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(<span class="built_in">malloc</span>(size));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_MMAP</span></span><br><span class="line">    a = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(<span class="built_in">mmap</span>(<span class="literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_VECTOR_CON</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">char</span>&gt; <span class="title">v</span><span class="params">(size)</span></span>;</span><br><span class="line">    a = &amp;v[<span class="number">0</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_VECTOR_RESIZE</span></span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; v; v.<span class="built_in">resize</span>(size);</span><br><span class="line">    a = &amp;v[<span class="number">0</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_VECTOR_RESERVE</span></span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; v; v.<span class="built_in">reserve</span>(size);</span><br><span class="line">    a = &amp;v[<span class="number">0</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// first touch on node 0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">65536</span>; ++i) a[i + <span class="number">65536</span> * <span class="number">512</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// touch all on node 3</span></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;thread, <span class="literal">NULL</span>, init, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span> *&gt;(<span class="number">123</span>));</span><br><span class="line">    <span class="built_in">pthread_join</span>(thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// output pages which is on node 0.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; ++i) &#123;</span><br><span class="line">        <span class="type">char</span> *ptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(a) + i * <span class="number">65536</span>;</span><br><span class="line">        <span class="type">int</span> node;</span><br><span class="line">        <span class="built_in">get_mempolicy</span>(&amp;node, <span class="literal">NULL</span>, <span class="number">0</span>, (<span class="type">void</span> *)ptr, MPOL_F_NODE | MPOL_F_ADDR);</span><br><span class="line">        <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_NEW</span></span><br><span class="line">    <span class="keyword">delete</span>[] a;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_MALLOC</span></span><br><span class="line">     <span class="built_in">free</span>(a);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_MMAP</span></span><br><span class="line">    <span class="built_in">munmap</span>(a, size);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>g++ -o onetouch onetouch.cpp -pthread -lnuma -g</code>进行编译, 结果是</p>
<ul>
<li>Malloc和New都是0 512 513页面在Node0, 有三个页面是因为Page 0被Malloc写入了最前面16个Byte记录了状态和大小出发First Touch, 因此, 后面的<code>a[0]</code>并不是页面开始, 而是页面0x10之后的位置, 因此写入Page 512的过程也写入了513的前16Byte.</li>
<li>vector的reserve由于没有初始化, 所以和malloc和new结果是一样的. 但是使用起来很不方便, 因为vector的size依然是0, 虽然发现可以通过下标访问(只有<code>at</code>才开边界检查), 但是还是有很多不方便</li>
<li>mmap由于不存在开头的16B, 因此只触碰了512页面</li>
<li>vector构造函数, <code>resize</code>的初始化行为都会触发first touch</li>
</ul>
<p>因此, 如果有一个vector的程序, 想要使用first touch, 改成指针太复杂了, 最好的方法就是reserve之后想办法修改掉size.</p>
<h3 id="如何进行的初始化"><a href="#如何进行的初始化" class="headerlink" title="如何进行的初始化"></a>如何进行的初始化</h3><p>我们可以直接找到源码, 因为是主要看他的构造的部分, 所以先<code>reserve</code>申请了空间, 之后调用相同参数的<code>resize</code>的情况.</p>
<p>首先在<code>bits/stl_vector.h</code>里面定义了resize. 代码也可在<a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc-7.5.0/libstdc++/api/a00587_source.html">官网</a>上直接看</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">resize</span><span class="params">(size_type __new_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (__new_size &gt; <span class="built_in">size</span>())</span><br><span class="line">_M_default_append(__new_size - <span class="built_in">size</span>());</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (__new_size &lt; <span class="built_in">size</span>())</span><br><span class="line">_M_erase_at_end(<span class="keyword">this</span>-&gt;_M_impl._M_start + __new_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们的显然是走的if的通路, 继续看, 定义在<code>bits/vector.tcc</code>, 调用并修改了<code>this-&gt;_M_impl._M_finish</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line"><span class="type">void</span></span><br><span class="line">vector&lt;_Tp, _Alloc&gt;::</span><br><span class="line">_M_default_append(size_type __n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__n != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size_type</span>(<span class="keyword">this</span>-&gt;_M_impl._M_end_of_storage</span><br><span class="line">        - <span class="keyword">this</span>-&gt;_M_impl._M_finish) &gt;= __n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_M_impl._M_finish =</span><br><span class="line">    std::__uninitialized_default_n_a(<span class="keyword">this</span>-&gt;_M_impl._M_finish,</span><br><span class="line">                        __n, _M_get_Tp_allocator());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>bits/stl_uninitialized.h</code>里面<code>__uninitialized_default_n_a</code>调用了<code>std::__uninitialized_default_n(__first, __n);</code>在同文件中定义为(对于一些自类是循环调用构造函数)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ForwardIterator, <span class="keyword">typename</span> _Size&gt;</span><br><span class="line"><span class="keyword">inline</span> _ForwardIterator</span><br><span class="line">__uninitialized_default_n(_ForwardIterator __first, _Size __n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;_ForwardIterator&gt;::value_type</span><br><span class="line">_ValueType;</span><br><span class="line">    <span class="comment">// trivial types can have deleted assignment</span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> __assignable = is_copy_assignable&lt;_ValueType&gt;::value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> __uninitialized_default_n_1&lt;__is_trivial(_ValueType)</span><br><span class="line">                    &amp;&amp; __assignable&gt;::</span><br><span class="line">__uninit_default_n(__first, __n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终这个<code>__uninit_default_n</code>调用<code>bits/stl_algobase.h</code>下面的<code>std::fill_n(__first, __n, _ValueType())</code>, 调用<code>std::__fill_n_a(std::__niter_base(__first), __n, __value)</code>最终调用了这个</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span></span><br><span class="line">__gnu_cxx::__enable_if&lt;__is_byte&lt;_Tp&gt;::__value, <span class="type">void</span>&gt;::__type</span><br><span class="line">__fill_a(_Tp* __first, _Tp* __last, <span class="type">const</span> _Tp&amp; __c)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> _Tp __tmp = __c;</span><br><span class="line">    <span class="keyword">if</span> (<span class="type">const</span> <span class="type">size_t</span> __len = __last - __first)</span><br><span class="line">__builtin_memset(__first, <span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt;(__tmp), __len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="简单的解决方案"><a href="#简单的解决方案" class="headerlink" title="简单的解决方案"></a>简单的解决方案</h3><p>要Resize Without Initialization, <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/7689406/resizing-a-c-stdvectorchar-without-initializing-data">一些回答</a>说是可以设计一个类包装一下, 用空的构造函数替代掉上面的memset(感觉应该是可行的). 但是用起来太麻烦太难用了. </p>
<h2 id="访问私有成员"><a href="#访问私有成员" class="headerlink" title="访问私有成员"></a>访问私有成员</h2><p>这样看起来最简单的可能还是<code>reserve</code>之后修改内部的大小看起来最好. 我们可以使用friend来访问, 但是如果我们不想修改类定义呢? 比如他是一个库函数.</p>
<h3 id="继承来解决"><a href="#继承来解决" class="headerlink" title="继承来解决"></a>继承来解决</h3><p>不难发现基类里面一个类存放了begin和end</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_Vector_base</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">         <span class="keyword">struct</span> <span class="title class_">_Vector_impl</span></span><br><span class="line">      : <span class="keyword">public</span> _Tp_alloc_type</span><br><span class="line">      &#123;</span><br><span class="line">        pointer _M_start;</span><br><span class="line">        pointer _M_finish;</span><br><span class="line">        pointer _M_end_of_storage;</span><br><span class="line">        ...</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>而vector是protected继承的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc = std::allocator&lt;_Tp&gt; &gt;</span><br><span class="line">    <span class="keyword">class</span> vector : <span class="keyword">protected</span> _Vector_base&lt;_Tp, _Alloc&gt;</span><br></pre></td></tr></table></figure>

<p>这样的话, 我们定义一个模板类, 继承vector然后设置一个<code>resize_without_init</code>就可以了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc = std::allocator&lt;_Tp&gt; &gt;</span><br><span class="line">    <span class="keyword">class</span> myvector : <span class="keyword">protected</span> vector&lt;_Tp, _Alloc&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">void</span> <span class="built_in">resize_without_init</span>(<span class="type">size_t</span> new_size) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">reserve</span>(new_size);</span><br><span class="line">            <span class="comment">// size = storage;</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;_M_impl._M_finish = <span class="keyword">this</span>-&gt;_M_impl._M_end_of_storage;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>可以直接把<code>vector</code>转化成<code>my</code>完整代码就是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc = std::allocator&lt;_Tp&gt; &gt;</span><br><span class="line">    <span class="keyword">class</span> myvector : <span class="keyword">public</span> std::vector&lt;_Tp, _Alloc&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">void</span> <span class="built_in">resize_without_init</span>(<span class="type">size_t</span> new_size) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">reserve</span>(new_size);</span><br><span class="line">            <span class="comment">// size = storage;</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;_M_impl._M_finish = <span class="keyword">this</span>-&gt;_M_impl._M_end_of_storage;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    (<span class="keyword">reinterpret_cast</span>&lt;myvector&lt;<span class="type">int</span>&gt;&amp;&gt;(v)).<span class="built_in">resize_without_init</span>(<span class="number">65536</span><span class="number">-24</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;size: &quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; capacity: &quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>限制: 只能Protected</p>
<h3 id="直接计算内存地址访问-转化成相同内存分布的类"><a href="#直接计算内存地址访问-转化成相同内存分布的类" class="headerlink" title="直接计算内存地址访问&#x2F;转化成相同内存分布的类"></a>直接计算内存地址访问&#x2F;转化成相同内存分布的类</h3><p>但是对于连protected都不是的成员, 就没办法通过这样构造来解决问题了, 因为连派生类也无法访问.</p>
<p>可以通过类型转换为<strong>相同内存分布</strong>的类, 而这个类是public的. 这样来使用, 比如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pa</span><span class="params">()</span> </span>&#123; cout &lt;&lt; a &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    (<span class="built_in">reinterpret_cast</span>&lt;B&amp;&gt;(a)).a = <span class="number">114514</span>;</span><br><span class="line">    a.<span class="built_in">pa</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果知道具体的内存分配, 目标机器, 编译配置这些, 甚至可以手动计算偏移量.</p>
<p>限制: 太复杂了, 尤其是各种继承的时候, 基本上没有实用性</p>
<h3 id="特化成员模板函数"><a href="#特化成员模板函数" class="headerlink" title="特化成员模板函数"></a>特化成员模板函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pa</span><span class="params">()</span> </span>&#123; cout &lt;&lt; a &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">f</span><span class="params">(T t)</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">namespace</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Y</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">X::f</span><span class="params">( Y )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = <span class="number">114514</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X x;</span><br><span class="line">    x.<span class="built_in">pa</span>();</span><br><span class="line">    x.<span class="built_in">f</span>( <span class="built_in">Y</span>() );</span><br><span class="line">    x.<span class="built_in">pa</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成员模板函数可以实例化, 因此可以自己手动实例化一个没有用的模板函数, 这时候就可以来访问了</p>
<p>限制: 只能在有public成员模板函数的时候才能用, 并且拥有和类<code>X</code>相同的权限(无法访问<code>X</code>基类的private).</p>
<h3 id="劫持私有函数"><a href="#劫持私有函数" class="headerlink" title="劫持私有函数"></a>劫持私有函数</h3><p>这个应该是最精巧的</p>
<p>这个是看到的reddit上网友的<a target="_blank" rel="noopener" href="https://www.reddit.com/r/cpp/comments/6friuu/resize_stringvector_without_initialization/?rdt=38109">讨论</a>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;whoops&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> PMember = <span class="built_in">void</span> (A::*)(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hijack</span><span class="params">(A&amp; s, <span class="type">int</span> n, <span class="type">char</span> dummy = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;PMember pf, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Hijack</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">hijack</span><span class="params">(A&amp; s, <span class="type">int</span> n, T)</span> </span>&#123;</span><br><span class="line">    (s.*pf)(n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">struct</span> <span class="title class_">Hijack</span>&lt;&amp;A::f, <span class="type">char</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  A a;</span><br><span class="line">  <span class="built_in">hijack</span>(a, <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>typename T</code>是可以省略的, 不太懂为什么要加这个</p>
<p>大概就是先设置一个函数指针的类型, 作为类模板参数, 类模板实例化出来一个类, 利用友元函数来进行访问. 这样来绕过检查.</p>
<blockquote>
<p>Yup, it works because explicit template instantiation ignores access restrictions, and the friend definition “leaks” the templated type out of the class, without having to write it anywhere.</p>
</blockquote>
<p>限制: 很精巧, 非常的Magic, 但是只能类成员函数</p>
<h2 id="Folly库的实现"><a href="#Folly库的实现" class="headerlink" title="Folly库的实现"></a>Folly库的实现</h2><p>Folly是FaceBook的一个C++14的库, 自称是对std和boost库的补充.</p>
<p>Folly的<a target="_blank" rel="noopener" href="https://github.com/facebook/folly/blob/main/folly/memory/UninitializedMemoryHacks.h"><code>UninitializedMemoryHacks.h</code></a>中, 给出了一个vector不初始化的实现.</p>
<p>最初的定义是这样的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;</span><br><span class="line">    <span class="keyword">typename</span> T,</span><br><span class="line">    <span class="keyword">typename</span> = <span class="keyword">typename</span> std::enable_if&lt;</span><br><span class="line">        std::is_trivially_destructible&lt;T&gt;::value &amp;&amp;</span><br><span class="line">        !std::is_same&lt;T, <span class="type">bool</span>&gt;::value&gt;::type&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">resizeWithoutInitialization</span>(std::vector&lt;T&gt;&amp; v, std::<span class="type">size_t</span> n) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= v.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    v.<span class="built_in">resize</span>(n);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; v.<span class="built_in">capacity</span>()) &#123;</span><br><span class="line">      v.<span class="built_in">reserve</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    detail::<span class="built_in">unsafeVectorSetLargerSize</span>(v, n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是更大的空间就执行<code>reserve</code>, 之后就是<code>detail::unsafeStringSetLargerSize(s, n);</code></p>
<p>实现似乎简单粗暴了很多…</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unsafeVectorSetLargerSize</span><span class="params">(std::vector&lt;T&gt;&amp; v, std::<span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> real = std::vector&lt;T&gt;;</span><br><span class="line">  <span class="keyword">using</span> fake = std_vector_layout&lt;T&gt;;</span><br><span class="line">  <span class="keyword">using</span> pointer = <span class="keyword">typename</span> fake::pointer;</span><br><span class="line">  <span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(fake) == <span class="built_in">sizeof</span>(real), <span class="string">&quot;mismatch&quot;</span>);</span><br><span class="line">  <span class="built_in">static_assert</span>(<span class="built_in">alignof</span>(fake) == <span class="built_in">alignof</span>(real), <span class="string">&quot;mismatch&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> <span class="type">const</span> l = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">char</span>*&gt;(&amp;v);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span>&amp; e = *<span class="built_in">reinterpret_cast</span>&lt;pointer*&gt;(l + <span class="built_in">offsetof</span>(fake, _M_finish));</span><br><span class="line">  e += (n - v.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接用的偏置来拿到的<code>_M_finish</code>这个地址, 自认为自己的实现更优雅一点（X</p>
<p>layout是libstdc++里面的内存分布…</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">std_vector_layout_impl</span> &#123;</span><br><span class="line">  <span class="built_in">static_assert</span>(!std::is_same&lt;T, <span class="type">bool</span>&gt;::value, <span class="string">&quot;bad instance&quot;</span>);</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> A&gt;</span><br><span class="line">  <span class="keyword">using</span> <span class="type">alloc_traits_t</span> = <span class="keyword">typename</span> __gnu_cxx::__alloc_traits&lt;A&gt;;</span><br><span class="line">  <span class="keyword">using</span> allocator_type = Alloc;</span><br><span class="line">  <span class="keyword">using</span> allocator_traits = <span class="type">alloc_traits_t</span>&lt;allocator_type&gt;;</span><br><span class="line">  <span class="keyword">using</span> rebound_allocator_type =</span><br><span class="line">      <span class="keyword">typename</span> allocator_traits::<span class="keyword">template</span> rebind&lt;T&gt;::other;</span><br><span class="line">  <span class="keyword">using</span> rebound_allocator_traits = <span class="type">alloc_traits_t</span>&lt;rebound_allocator_type&gt;;</span><br><span class="line">  <span class="keyword">using</span> pointer = <span class="keyword">typename</span> rebound_allocator_traits::pointer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">impl_type</span> : rebound_allocator_type &#123;</span><br><span class="line">    pointer _M_start;</span><br><span class="line">    pointer _M_finish;</span><br><span class="line">    pointer _M_end_of_storage;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于msvc的实现就是, 和我继承的方式差不多</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tag, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MakeUnsafeVectorSetLargerSize</span> : std::vector&lt;T&gt; &#123;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">unsafeVectorSetLargerSizeImpl</span><span class="params">(std::vector&lt;T&gt;&amp; v, std::<span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    v._Mylast() += (n - v.<span class="built_in">size</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/7689406/resizing-a-c-stdvectorchar-without-initializing-data">Resizing a C++ std::vector<char> without initializing data [duplicate] - StackOverflow</a></li>
<li><a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc-7.5.0/libstdc++/api/a00587_source.html">Libstdc++: stl_vector.h Source code - gcc.gnu.org</a></li>
<li><a target="_blank" rel="noopener" href="http://www.gotw.ca/gotw/076.htm">Uses and Abuses of Access Rights - GotW #76</a></li>
<li><a target="_blank" rel="noopener" href="https://www.reddit.com/r/cpp/comments/6friuu/resize_stringvector_without_initialization/?rdt=38109">Resize string&#x2F;vector without initialization - Reddit r&#x2F;cpp</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/facebook/folly/blob/main/folly/memory/UninitializedMemoryHacks.h">folly&#x2F;folly&#x2F;memory&#x2F;UninitializedMemoryHacks.h - Github</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zombie12138.github.io/2023/NUMA%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8CFirstTouch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zombie12138">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zombie's">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/NUMA%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8CFirstTouch/" class="post-title-link" itemprop="url">NUMA内存分配, FirstTouch从接触到放弃</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-17 15:47:09" itemprop="dateCreated datePublished" datetime="2023-09-17T15:47:09+08:00">2023-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-13 15:47:59" itemprop="dateModified" datetime="2023-10-13T15:47:59+08:00">2023-10-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>实验在2Socket * 鲲鹏920-Server(一共128C 256G 4NUMA)进行, 操作系统<code>CentOS Linux release 7.9.2009 (AltArch)</code>, 内核版本<code>4.14.0-115.el7a.0.1.aarch64</code>, GCC 7.5.0, 开启了Page Size(65536, 64KB), (GNU libc) 2.17</p>
<h2 id="NUMA"><a href="#NUMA" class="headerlink" title="NUMA"></a>NUMA</h2><p>一般的个人电脑都是UMA(Uniform Memory Access), 不同的核心访问速度是相同的, 但是在服务器CPU中, 可能有多个CPU socket, CPU访问另一个处理器上的内存会更慢一些, 但是访问本地的内存会快一些， 这就是NUMA(Non-Uniform Memory Access), 当然, 为了提高单个处理器的带宽, 让他能匹配不断增长的核心数, 一些厂商也会处于拓展性等考虑把单个处理器上的核心分为几组, 每一组是一个NUMA Node. 核心自己所在的Node叫Local Node; 其他的Node就是Remote Node, 访存延迟和带宽都会更加受限; 有一些会把相同Socket不同的Node成为Neighbour Node， 速度介于两者之间.</p>
<p>比如下图的鲲鹏920-Server, 每一个SoC拥有两个CPU-Compute Die, 每一个CPU Compute Die拥有两对, 4个DDR控制器, 一个SoC有8个DDR控制器, 可以达到200GB&#x2F;s的带宽. 如图所示, 多个鲲鹏SoC就会有4个NUMA Node.</p>
<img src="/2023/NUMA%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8CFirstTouch/kunpeng910-chipset-solution.png" class="" title="kunpeng910-chipset-solution">

<img src="/2023/NUMA%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8CFirstTouch/kunpeng-numa.png" class="" title="kunpeng-numa">

<p>一些CPU也可以开启或者关闭NUMA, 甚至可以设置NUMA Node的数量. 可以使用<code>numactl -H</code>或者<code>lscpu</code>来查看是否存在NUMA, 比如在鲲鹏920上的输出如下</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ numactl -H</span><br><span class="line">available: 4 nodes (0-3)</span><br><span class="line">node 0 cpus: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31</span><br><span class="line">node 0 size: 64588 MB</span><br><span class="line">node 0 free: 54950 MB</span><br><span class="line">node 1 cpus: 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63</span><br><span class="line">node 1 size: 65465 MB</span><br><span class="line">node 1 free: 56654 MB</span><br><span class="line">node 2 cpus: 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95</span><br><span class="line">node 2 size: 65465 MB</span><br><span class="line">node 2 free: 47834 MB</span><br><span class="line">node 3 cpus: 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127</span><br><span class="line">node 3 size: 65463 MB</span><br><span class="line">node 3 free: 54275 MB</span><br><span class="line">node distances:</span><br><span class="line">node   0   1   2   3</span><br><span class="line">  0:  10  16  32  33</span><br><span class="line">  1:  16  10  25  32</span><br><span class="line">  2:  32  25  10  16</span><br><span class="line">  3:  33  32  16  10</span><br></pre></td></tr></table></figure>

<p>NUMA带来的好处就是可拓展性, 内存带宽跟随CPU核心数量上涨.</p>
<p>但是需要解决的问题也很多. 首先一个直观的就是, 我的程序很可能访问远端的内存, 这时候内存的速度就会下降很多. 另一方面, 可能会导致这种NUMA可能导致很多CPU争用一个内存控制器, 或者加大通讯压力等. 最后伪共享这些可能进一步加剧性能下降.</p>
<p>解决的办法也有很多, 可以通过NUMA感知的内存分配, 绑定核心(taskset, OpenMP proc bind, numactl等), 异步通讯, NUMA感知的算法等等来进行解决.</p>
<h2 id="Linux的NUMA内存分配策略"><a href="#Linux的NUMA内存分配策略" class="headerlink" title="Linux的NUMA内存分配策略"></a>Linux的NUMA内存分配策略</h2><p>说的比较乱, 最好还是去看<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/admin-guide/mm/numa_memory_policy.html">Linux Kernel Documentation</a></p>
<p>可以通过设置内核参数, 比如<code>zone_reclaim_mode</code>, 为0则内存不足的时候在远端的CPU分配内存; 也可以使用一些工具或者库, 比如<code>numactl</code>, <code>numad</code>来手动配置策略, 比如<code>numactl --interleave=all</code>; 还可以使用libnuma在编程中手动指定分配位置. </p>
<p>但是总的来说有下面几种类型: <code>default</code>在本地numa node上分配内存; <code>bind</code>指定在一系列特定的numa node上分配内存; <code>interleave</code>在一系列numa node上分配交错内存; <code>preferred</code>指定优先选取的node</p>
<p>但是Linux系统的分配策略不是在申请内存的时候就生效的, 听过一个笑话: 软件, 我就是申请内存, 我不用, 就是玩; OS, 我就标记一下, 但我不给你. 当然这只是笑话了. Linux内存分配策略就是<code>First Touch</code>, 第一个访问内存页(一般4K)的时候, 申请才会生效, 其他当然不影响, 但是默认的策略就会收到这个影响, <strong>会把内存页分配给访问这个内存页的Node</strong>.</p>
<h2 id="First-Touch测试向量加法"><a href="#First-Touch测试向量加法" class="headerlink" title="First Touch测试向量加法"></a>First Touch测试向量加法</h2><h3 id="一个线程来初始化"><a href="#一个线程来初始化" class="headerlink" title="一个线程来初始化"></a>一个线程来初始化</h3><p>来手动写一个OpenMP的加法. 然后使用First Touch策略来优化.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numa.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">short</span> data_type;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> mem_size = <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024U</span>;</span><br><span class="line">    data_type *a = <span class="built_in">malloc</span>(mem_size);</span><br><span class="line">    data_type *b = <span class="built_in">malloc</span>(mem_size);</span><br><span class="line">    data_type *c = <span class="built_in">malloc</span>(mem_size);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> len = mem_size / <span class="built_in">sizeof</span>(data_type);</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel default(shared) num_threads(128)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> thread_id = <span class="built_in">omp_get_thread_num</span>();</span><br><span class="line">        <span class="type">int</span> cpu_id = <span class="built_in">sched_getcpu</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread %03d is running on CPU %03d\n&quot;</span>, thread_id, cpu_id);</span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> omp for</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            a[i] = <span class="number">3</span>;</span><br><span class="line">            b[i] = <span class="number">4</span>;</span><br><span class="line">            c[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> t1, t2;</span><br><span class="line">    <span class="built_in">gettimeofday</span>(&amp;t1, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#    <span class="keyword">pragma</span> omp parallel default(shared) num_threads(128)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> thread_id = <span class="built_in">omp_get_thread_num</span>();</span><br><span class="line">        <span class="type">int</span> cpu_id = <span class="built_in">sched_getcpu</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// get numa node id</span></span><br><span class="line">        <span class="type">int</span> status[<span class="number">1</span>];</span><br><span class="line">        status[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">        data_type *ptr = a + (len / <span class="number">128</span> * thread_id);</span><br><span class="line">        <span class="built_in">move_pages</span>(<span class="number">0</span> <span class="comment">/*self memory */</span>, <span class="number">1</span>, &amp;ptr,</span><br><span class="line">              <span class="literal">NULL</span>, status, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread %03d is running on CPU %03d, addr on node %d\n&quot;</span>, thread_id, cpu_id, status[<span class="number">0</span>]);</span><br><span class="line"><span class="meta">#       <span class="keyword">pragma</span> omp for</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">           c[i] = a[i] + b[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">gettimeofday</span>(&amp;t2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> deltat = (t2.tv_sec-t1.tv_sec) * <span class="number">1000000</span> + t2.tv_usec-t1.tv_usec;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Delt = %u \n&quot;</span>, deltat);</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// disable optimization</span></span><br><span class="line">    <span class="meta"># <span class="keyword">pragma</span> aomp parallel for default(shared) num_threads(128) reduction(+: sum)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; ++i) &#123;</span><br><span class="line">        sum += c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, sum);</span><br><span class="line">    <span class="built_in">free</span>(a);<span class="built_in">free</span>(b);<span class="built_in">free</span>(c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序先申请3个2GB的数组, 然后用一个OpenMP的线程进行初始化, 之后使用128个线程去做向量加法, 打印出来<strong>加法部分的时间</strong>. 最后的加法输出是很简单的方法来防止编译器优化(如果开了)…</p>
<p>输出OpenMP初始化和向量加法的线程和物理核心的映射关系, 同时还会输出该线程处理的数据内存第一个Page所在的NUMA Node.</p>
<p>OpenMP的for会把for循环任务按照循环变量切分成128份, 从第一份到最后一份依次分配给0~127号线程, 但是线程执行了在哪个CPU是调度决定的.</p>
<p>使用<code>gcc -o sum -O0 -pthread -lnuma -fopenmp sum.c</code>编译出来, 执行<code>./sum</code>. 注意, 上面的初始化是由一个线程完成的, 但是执行向量加法的操作是128的线程一起执行. 最终加法部分用时是<code>225930us</code></p>
<h3 id="128个线程来初始化"><a href="#128个线程来初始化" class="headerlink" title="128个线程来初始化"></a>128个线程来初始化</h3><p>按照我们之前的说的First Touch, 初始化由一个线程给出, 运行中初始化由62号Core执行, 所以全在1号Node. (其实有很少几率少量的输出是再其他的节点)</p>
<p>但是如果使用128线程来进行数组数值的初始化, 由于这些线程被分配到不同Node的Core, 内存也会分不到不同的Node. 只需要把初始化的线程数改成128, 会来到<code>173465us</code>附近. 快了一倍.</p>
<p>很容易想到这是由于NUMA带来的结果. 之前只能用到一个NUMA Node的内存, 现在可以用到所有的NUMA内存的带宽. 向量加法是一个计算很稀疏的操作, 是memory bound的. </p>
<p>可以通过这样来统计一下每一段内存地起始地址在哪一个node中<code>./sum  | grep node | awk &#39;&#123;print $11&#125;&#39; | sort | uniq -c</code></p>
<p>得到还是有一些意外的, 在Node 1上最多.</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">27 0</span><br><span class="line">59 1</span><br><span class="line">10 2</span><br><span class="line">32 3</span><br></pre></td></tr></table></figure>

<p>理论上应该是在4个Node上均匀分布, 为什么是这样呢…</p>
<p>首先想到的就是可能是OpenMP的Paralle For, 于是赶紧查书, 也测试了一下, 确实是分成几段分别运行.</p>
<p>其次想到, 是不是获取Node编号的api有问题, 换成了下面的API获取Node编号</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numaif.h&gt;</span></span></span><br><span class="line">data_type *ptr = a;</span><br><span class="line"><span class="type">int</span> node;</span><br><span class="line"><span class="built_in">get_mempolicy</span>(&amp;node, <span class="literal">NULL</span>, <span class="number">0</span>, (<span class="type">void</span> *)ptr, MPOL_F_NODE | MPOL_F_ADDR);</span><br></pre></td></tr></table></figure>

<p>但是上面的api也是一样效果.</p>
<p>想到问题可能是绑核, 尝试绑核之后, 有所好转, 但是还是没有解决.</p>
<p>是不是Linux内存在分配时候在一段的前面打了奇怪的标签, 导致提前First Touch生效. 这个也不知道用什么来检测内存访问或者Page Fault. 想的是使用Perf来测一下Page Fault, 或者使用strace看一下system call.</p>
<h2 id="First-Touch出问题"><a href="#First-Touch出问题" class="headerlink" title="First Touch出问题"></a>First Touch出问题</h2><h3 id="Strace"><a href="#Strace" class="headerlink" title="Strace"></a>Strace</h3><p>先strace看一下调用(感觉没用, 就是爱看), trace在<a href="/2023/NUMA%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8CFirstTouch/strace_sum.txt" title="可以下载">可以下载</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ strace ./sum</span><br></pre></td></tr></table></figure>

<p>首先是调用执行这个sum</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">execve(<span class="string">&quot;./sum&quot;</span>, [<span class="string">&quot;./sum&quot;</span>], <span class="number">0xffffea134380</span> <span class="comment">/* 44 vars */</span>) = <span class="number">0</span></span><br><span class="line"><span class="comment">// 查询堆顶地址</span></span><br><span class="line">brk(<span class="literal">NULL</span>)                               = <span class="number">0x2c0e0000</span></span><br></pre></td></tr></table></figure>

<p>后面是一堆大量的这些尝试打开这些so的, 但是都是不存在, 不是很懂…</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openat(AT_FDCWD, <span class="string">&quot;/home/nscc-gz/guoych/local/spack/opt/spack/linux-centos7-aarch64/gcc-7.5.0/gcc-7.5.0-jgj56pzbhcc7c5ltarj6nrmqrkrzaoia/lib64/tls/aarch64/libnuma.so.1&quot;</span>, O_RDONLY|O_CLOEXEC) = <span class="number">-1</span> ENOENT (No such file or directory)</span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/home/nscc-gz/guoych/local/spack/opt/spack/linux-centos7-aarch64/gcc-7.5.0/gcc-7.5.0-jgj56pzbhcc7c5ltarj6nrmqrkrzaoia/lib64/tls/aarch64&quot;</span>, <span class="number">0xfffffe6aa250</span>, <span class="number">0</span>) = <span class="number">-1</span> ENOENT (No such file or directory)</span><br></pre></td></tr></table></figure>

<p>也有打开成功, 然后mmap的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">openat(AT_FDCWD, <span class="string">&quot;/etc/ld.so.cache&quot;</span>, O_RDONLY|O_CLOEXEC) = <span class="number">3</span></span><br><span class="line">fstat(<span class="number">3</span>, &#123;st_mode=S_IFREG|<span class="number">0644</span>, st_size=<span class="number">86270</span>, ...&#125;) = <span class="number">0</span></span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">86270</span>, PROT_READ, MAP_PRIVATE, <span class="number">3</span>, <span class="number">0</span>) = <span class="number">0x4000158f0000</span></span><br><span class="line">close(<span class="number">3</span>)                                = <span class="number">0</span></span><br><span class="line">openat(AT_FDCWD, <span class="string">&quot;/lib64/libnuma.so.1&quot;</span>, O_RDONLY|O_CLOEXEC) = <span class="number">3</span></span><br><span class="line">read(<span class="number">3</span>, <span class="string">&quot;\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0\267\0\1\0\0\00004\0\0\0\0\0\0&quot;</span>..., <span class="number">832</span>) = <span class="number">832</span></span><br><span class="line">fstat(<span class="number">3</span>, &#123;st_mode=S_IFREG|<span class="number">0755</span>, st_size=<span class="number">71208</span>, ...&#125;) = <span class="number">0</span></span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">149088</span>, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, <span class="number">3</span>, <span class="number">0</span>) = <span class="number">0x400015910000</span></span><br><span class="line">mmap(<span class="number">0x400015920000</span>, <span class="number">131072</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, <span class="number">3</span>, <span class="number">0</span>) = <span class="number">0x400015920000</span></span><br><span class="line">close(<span class="number">3</span>)                                = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>很久很久之后, 终于加载了一部分, 之后把一部分页设置成只读(有些是库, 比如<code>/lib64/libc.so.6</code>开头是<code>0x400015b40000</code>, 有一些没有找到出处)…</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mprotect(<span class="number">0x400015b40000</span>, <span class="number">65536</span>, PROT_READ) = <span class="number">0</span></span><br><span class="line">mprotect(<span class="number">0x400015bb0000</span>, <span class="number">65536</span>, PROT_READ) = <span class="number">0</span></span><br><span class="line">mprotect(<span class="number">0x400015b80000</span>, <span class="number">65536</span>, PROT_READ) = <span class="number">0</span></span><br><span class="line">mprotect(<span class="number">0x4000159b0000</span>, <span class="number">65536</span>, PROT_READ) = <span class="number">0</span></span><br><span class="line">mprotect(<span class="number">0x400015970000</span>, <span class="number">65536</span>, PROT_READ) = <span class="number">0</span></span><br><span class="line">mprotect(<span class="number">0x400015920000</span>, <span class="number">65536</span>, PROT_READ) = <span class="number">0</span></span><br><span class="line">mprotect(<span class="number">0x410000</span>, <span class="number">65536</span>, PROT_READ)    = <span class="number">0</span></span><br><span class="line">mprotect(<span class="number">0x4000158b0000</span>, <span class="number">65536</span>, PROT_READ) = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>把<code>/etc/ld.so.cache</code>关掉内存映射</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">munmap(<span class="number">0x4000158f0000</span>, <span class="number">86270</span>)           = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>之后一系列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置tid地址</span></span><br><span class="line">set_tid_address(<span class="number">0x4000158c6210</span>)         = <span class="number">951</span></span><br><span class="line"><span class="comment">// 告诉内核，鲁棒性列表的地址和大小，以便在线程异常终止时，内核可以自动扫描这个列表，并执行相应的清理操作</span></span><br><span class="line">set_robust_list(<span class="number">0x4000158c6220</span>, <span class="number">24</span>)     = <span class="number">0</span></span><br><span class="line"><span class="comment">// 设置signal的处理函数还有mask</span></span><br><span class="line">rt_sigaction(SIGRTMIN, &#123;sa_handler=<span class="number">0x4000159964a4</span>, sa_mask=[], sa_flags=SA_SIGINFO&#125;, <span class="literal">NULL</span>, <span class="number">8</span>) = <span class="number">0</span></span><br><span class="line">rt_sigaction(SIGRT_1, &#123;sa_handler=<span class="number">0x400015996584</span>, sa_mask=[], sa_flags=SA_RESTART|SA_SIGINFO&#125;, <span class="literal">NULL</span>, <span class="number">8</span>) = <span class="number">0</span></span><br><span class="line">rt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], <span class="literal">NULL</span>, <span class="number">8</span>) = <span class="number">0</span></span><br><span class="line"><span class="comment">// 获取对战大小</span></span><br><span class="line">getrlimit(RLIMIT_STACK, &#123;rlim_cur=RLIM64_INFINITY, rlim_max=RLIM64_INFINITY&#125;) = <span class="number">0</span></span><br><span class="line"><span class="comment">// 应该是查看cpu数量, 根据这个设置openmp线程数量</span></span><br><span class="line">openat(AT_FDCWD, <span class="string">&quot;/sys/devices/system/cpu&quot;</span>, O_RDONLY|O_NONBLOCK|O_CLOEXEC|O_DIRECTORY) = <span class="number">3</span></span><br><span class="line"><span class="comment">// 查询堆顶地址</span></span><br><span class="line">brk(<span class="literal">NULL</span>)                               = <span class="number">0xd380000</span></span><br><span class="line"><span class="comment">// 扩展堆内存相当于申请192KB内存?</span></span><br><span class="line">brk(<span class="number">0xd3b0000</span>)                          = <span class="number">0xd3b0000</span></span><br><span class="line"><span class="comment">// 读取目录内容???14个目录项... 不懂</span></span><br><span class="line">getdents64(<span class="number">3</span>, <span class="comment">/* 144 entries */</span>, <span class="number">32768</span>) = <span class="number">4520</span></span><br><span class="line">getdents64(<span class="number">3</span>, <span class="comment">/* 0 entries */</span>, <span class="number">32768</span>)   = <span class="number">0</span></span><br><span class="line">close(<span class="number">3</span>)                                = <span class="number">0</span></span><br><span class="line"><span class="comment">// 设置线程亲和性可以在所有的核心上执行</span></span><br><span class="line">sched_getaffinity(<span class="number">951</span>, <span class="number">16</span>, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>, <span class="number">36</span>, <span class="number">37</span>, <span class="number">38</span>, <span class="number">39</span>, <span class="number">40</span>, <span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>, <span class="number">44</span>, <span class="number">45</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">50</span>, <span class="number">51</span>, <span class="number">52</span>, <span class="number">53</span>, <span class="number">54</span>, <span class="number">55</span>, <span class="number">56</span>, <span class="number">57</span>, <span class="number">58</span>, <span class="number">59</span>, <span class="number">60</span>, <span class="number">61</span>, <span class="number">62</span>, <span class="number">63</span>, <span class="number">64</span>, <span class="number">65</span>, <span class="number">66</span>, <span class="number">67</span>, <span class="number">68</span>, <span class="number">69</span>, <span class="number">70</span>, <span class="number">71</span>, <span class="number">72</span>, <span class="number">73</span>, <span class="number">74</span>, <span class="number">75</span>, <span class="number">76</span>, <span class="number">77</span>, <span class="number">78</span>, <span class="number">79</span>, <span class="number">80</span>, <span class="number">81</span>, <span class="number">82</span>, <span class="number">83</span>, <span class="number">84</span>, <span class="number">85</span>, <span class="number">86</span>, <span class="number">87</span>, <span class="number">88</span>, <span class="number">89</span>, <span class="number">90</span>, <span class="number">91</span>, <span class="number">92</span>, <span class="number">93</span>, <span class="number">94</span>, <span class="number">95</span>, <span class="number">96</span>, <span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">102</span>, <span class="number">103</span>, <span class="number">104</span>, <span class="number">105</span>, <span class="number">106</span>, <span class="number">107</span>, <span class="number">108</span>, <span class="number">109</span>, <span class="number">110</span>, <span class="number">111</span>, <span class="number">112</span>, <span class="number">113</span>, <span class="number">114</span>, <span class="number">115</span>, <span class="number">116</span>, <span class="number">117</span>, <span class="number">118</span>, <span class="number">119</span>, <span class="number">120</span>, <span class="number">121</span>, <span class="number">122</span>, <span class="number">123</span>, <span class="number">124</span>, <span class="number">125</span>, <span class="number">126</span>, <span class="number">127</span>]) = <span class="number">16</span></span><br><span class="line"><span class="comment">// 检查进程状态</span></span><br><span class="line">openat(AT_FDCWD, <span class="string">&quot;/proc/self/status&quot;</span>, O_RDONLY) = <span class="number">3</span></span><br><span class="line">fstat(<span class="number">3</span>, &#123;st_mode=S_IFREG|<span class="number">0444</span>, st_size=<span class="number">0</span>, ...&#125;) = <span class="number">0</span></span><br><span class="line"><span class="comment">// 分配内存</span></span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">65536</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x4000158f0000</span></span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line">read(<span class="number">3</span>, <span class="string">&quot;Name:\tsum\nUmask:\t0002\nState:\tR (&quot;</span>..., <span class="number">1024</span>) = <span class="number">1024</span></span><br><span class="line">close(<span class="number">3</span>)                                = <span class="number">0</span></span><br><span class="line"><span class="comment">// free</span></span><br><span class="line">munmap(<span class="number">0x4000158f0000</span>, <span class="number">65536</span>)           = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">openat(AT_FDCWD, <span class="string">&quot;/sys/devices/system/node&quot;</span>, O_RDONLY|O_NONBLOCK|O_CLOEXEC|O_DIRECTORY) = <span class="number">3</span></span><br><span class="line"><span class="comment">// 猜测是读取Node的编号</span></span><br><span class="line">getdents64(<span class="number">3</span>, <span class="comment">/* 13 entries */</span>, <span class="number">32768</span>)  = <span class="number">408</span></span><br><span class="line"><span class="comment">// 读取Node2 meminfo</span></span><br><span class="line">openat(AT_FDCWD, <span class="string">&quot;/sys/devices/system/node/node2/meminfo&quot;</span>, O_RDONLY) = <span class="number">4</span></span><br><span class="line">fstat(<span class="number">4</span>, &#123;st_mode=S_IFREG|<span class="number">0444</span>, st_size=<span class="number">65536</span>, ...&#125;) = <span class="number">0</span></span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">65536</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x4000158f0000</span></span><br><span class="line">read(<span class="number">4</span>, <span class="string">&quot;Node 2 MemTotal:       67036992 &quot;</span>..., <span class="number">8192</span>) = <span class="number">1070</span></span><br><span class="line">read(<span class="number">4</span>, <span class="string">&quot;&quot;</span>, <span class="number">8192</span>)                       = <span class="number">0</span></span><br><span class="line">close(<span class="number">4</span>)                                = <span class="number">0</span></span><br><span class="line"><span class="comment">// 读取其他三个Node meminfo</span></span><br><span class="line"><span class="comment">// 之后free</span></span><br><span class="line">munmap(<span class="number">0x4000158f0000</span>, <span class="number">65536</span>)           = <span class="number">0</span></span><br><span class="line">getdents64(<span class="number">3</span>, <span class="comment">/* 0 entries */</span>, <span class="number">32768</span>)   = <span class="number">0</span></span><br><span class="line">close(<span class="number">3</span>)                                = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不是很懂, 重新设置了一下512*8个核心的亲和性, 然后又看了一眼CPU的核心数量</span></span><br><span class="line">sched_getaffinity(<span class="number">0</span>, <span class="number">512</span>, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>, <span class="number">36</span>, <span class="number">37</span>, <span class="number">38</span>, <span class="number">39</span>, <span class="number">40</span>, <span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>, <span class="number">44</span>, <span class="number">45</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">50</span>, <span class="number">51</span>, <span class="number">52</span>, <span class="number">53</span>, <span class="number">54</span>, <span class="number">55</span>, <span class="number">56</span>, <span class="number">57</span>, <span class="number">58</span>, <span class="number">59</span>, <span class="number">60</span>, <span class="number">61</span>, <span class="number">62</span>, <span class="number">63</span>, <span class="number">64</span>, <span class="number">65</span>, <span class="number">66</span>, <span class="number">67</span>, <span class="number">68</span>, <span class="number">69</span>, <span class="number">70</span>, <span class="number">71</span>, <span class="number">72</span>, <span class="number">73</span>, <span class="number">74</span>, <span class="number">75</span>, <span class="number">76</span>, <span class="number">77</span>, <span class="number">78</span>, <span class="number">79</span>, <span class="number">80</span>, <span class="number">81</span>, <span class="number">82</span>, <span class="number">83</span>, <span class="number">84</span>, <span class="number">85</span>, <span class="number">86</span>, <span class="number">87</span>, <span class="number">88</span>, <span class="number">89</span>, <span class="number">90</span>, <span class="number">91</span>, <span class="number">92</span>, <span class="number">93</span>, <span class="number">94</span>, <span class="number">95</span>, <span class="number">96</span>, <span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">102</span>, <span class="number">103</span>, <span class="number">104</span>, <span class="number">105</span>, <span class="number">106</span>, <span class="number">107</span>, <span class="number">108</span>, <span class="number">109</span>, <span class="number">110</span>, <span class="number">111</span>, <span class="number">112</span>, <span class="number">113</span>, <span class="number">114</span>, <span class="number">115</span>, <span class="number">116</span>, <span class="number">117</span>, <span class="number">118</span>, <span class="number">119</span>, <span class="number">120</span>, <span class="number">121</span>, <span class="number">122</span>, <span class="number">123</span>, <span class="number">124</span>, <span class="number">125</span>, <span class="number">126</span>, <span class="number">127</span>, ...]) = <span class="number">512</span></span><br><span class="line">openat(AT_FDCWD, <span class="string">&quot;/sys/devices/system/cpu&quot;</span>, O_RDONLY|O_NONBLOCK|O_CLOEXEC|O_DIRECTORY) = <span class="number">3</span></span><br><span class="line">getdents64(<span class="number">3</span>, <span class="comment">/* 144 entries */</span>, <span class="number">32768</span>) = <span class="number">4520</span></span><br><span class="line">getdents64(<span class="number">3</span>, <span class="comment">/* 0 entries */</span>, <span class="number">32768</span>)   = <span class="number">0</span></span><br><span class="line">close(<span class="number">3</span>)                                = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取了一下状态, 猜测这两次都是一个库函数调用的, 先设置亲和性然后检查</span></span><br><span class="line">openat(AT_FDCWD, <span class="string">&quot;/proc/self/status&quot;</span>, O_RDONLY) = <span class="number">3</span></span><br><span class="line">fstat(<span class="number">3</span>, &#123;st_mode=S_IFREG|<span class="number">0444</span>, st_size=<span class="number">0</span>, ...&#125;) = <span class="number">0</span></span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">65536</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x4000158f0000</span></span><br><span class="line">read(<span class="number">3</span>, <span class="string">&quot;Name:\tsum\nUmask:\t0002\nState:\tR (&quot;</span>..., <span class="number">1024</span>) = <span class="number">1024</span></span><br><span class="line">read(<span class="number">3</span>, <span class="string">&quot;switches:\t484\nnonvoluntary_ctxt_&quot;</span>..., <span class="number">1024</span>) = <span class="number">44</span></span><br><span class="line">read(<span class="number">3</span>, <span class="string">&quot;&quot;</span>, <span class="number">1024</span>)                       = <span class="number">0</span></span><br><span class="line">close(<span class="number">3</span>)                                = <span class="number">0</span></span><br><span class="line">munmap(<span class="number">0x4000158f0000</span>, <span class="number">65536</span>)           = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>malloc内存分配</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fstat(<span class="number">1</span>, &#123;st_mode=S_IFREG|<span class="number">0664</span>, st_size=<span class="number">0</span>, ...&#125;) = <span class="number">0</span></span><br><span class="line"><span class="comment">// 这个不知道是干嘛的, 猜测可能是和使用管道或者重定向时候, 多线程输出缓冲区相关的</span></span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">65536</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x4000158f0000</span></span><br><span class="line"><span class="comment">// 分配三个2GB的内存</span></span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">2147549184</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x400015bd0000</span></span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">2147549184</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x400095be0000</span></span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">2147549184</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x400115bf0000</span></span><br></pre></td></tr></table></figure>

<p>然后重复了127次下面的clone线程的操作, OpenMP还是蛮节约的, 主线程也担任一个, 每个分配2MB的空间(应该是栈)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">2162688</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x400195c00000</span></span><br><span class="line">mprotect(<span class="number">0x400195c00000</span>, <span class="number">65536</span>, PROT_NONE) = <span class="number">0</span></span><br><span class="line">clone(child_stack=<span class="number">0x400195e0ea90</span>, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=<span class="number">0x400195e0f250</span>, tls=<span class="number">0x400195e0f870</span>, child_tidptr=<span class="number">0x400195e0f250</span>) = <span class="number">952</span></span><br></pre></td></tr></table></figure>

<p>后面都是只有主线程的一些调用, 可能是和线程同步或者写入缓冲区相关</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个应该是唤醒线程的? 但是为什么只唤醒了125而不是127?</span></span><br><span class="line">futex(<span class="number">0xd380804</span>, FUTEX_WAKE_PRIVATE, <span class="number">2147483647</span>) = <span class="number">125</span></span><br><span class="line">getcpu([<span class="number">52</span>], <span class="literal">NULL</span>, <span class="literal">NULL</span>)                = <span class="number">0</span></span><br><span class="line"><span class="comment">// 这两个应该是同步的?</span></span><br><span class="line">futex(<span class="number">0xd380914</span>, FUTEX_WAIT_PRIVATE, <span class="number">0</span>, <span class="literal">NULL</span>) = <span class="number">0</span></span><br><span class="line">futex(<span class="number">0xd380914</span>, FUTEX_WAIT_PRIVATE, <span class="number">8</span>, <span class="literal">NULL</span>) = <span class="number">0</span></span><br><span class="line"><span class="comment">// 这个应该是唤醒线程的? 但是为什么更少了?</span></span><br><span class="line">futex(<span class="number">0xd380804</span>, FUTEX_WAKE_PRIVATE, <span class="number">2147483647</span>) = <span class="number">61</span></span><br><span class="line">getcpu([<span class="number">50</span>], <span class="literal">NULL</span>, <span class="literal">NULL</span>)                = <span class="number">0</span></span><br><span class="line">get_mempolicy([MPOL_PREFERRED], <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0x400095be0010</span>, MPOL_F_NODE|MPOL_F_ADDR) = <span class="number">0</span></span><br><span class="line">futex(<span class="number">0xd380914</span>, FUTEX_WAIT_PRIVATE, <span class="number">16</span>, <span class="literal">NULL</span>) = <span class="number">0</span></span><br><span class="line">futex(<span class="number">0xd380914</span>, FUTEX_WAKE_PRIVATE, <span class="number">2147483647</span>) = <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>最后free; 最后输出结果, 这个是使用了管道之后, 因此, 所有的printf都libc优化到了一次调用, 如果是普通的执行, 就会再上面的两段中调用主线程的write; 以及最后的推出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">munmap(<span class="number">0x400015bd0000</span>, <span class="number">2147549184</span>)      = <span class="number">0</span></span><br><span class="line">munmap(<span class="number">0x400095be0000</span>, <span class="number">2147549184</span>)      = <span class="number">0</span></span><br><span class="line">munmap(<span class="number">0x400115bf0000</span>, <span class="number">2147549184</span>)      = <span class="number">0</span></span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;n node 0\nThread 104 is running o&quot;</span>..., <span class="number">2427</span>) = <span class="number">2427</span></span><br><span class="line">exit_group(<span class="number">0</span>)                           = ?</span><br></pre></td></tr></table></figure>

<h3 id="Malloc中mmap的allign-up"><a href="#Malloc中mmap的allign-up" class="headerlink" title="Malloc中mmap的allign up"></a>Malloc中mmap的allign up</h3><p>可以注意到… Malloc的空间比2GB多了65536Byte, 64KB的空间, 并且所有的调用mmap的malloc都是这样. 在想是不是因为这65536malloc处理的时候触发了First touch… malloc的太复杂, 打算以后再具体去看(#TODO).</p>
<p>但是打印了一下他们的ADDR, 发现地址是<code>0x400003820010</code>, 但是mmap得到的是<code>0x400003820000</code>. 说明前面少了16Byte, 但是还有65520大小的空间, 应该就是在末尾了.</p>
<p>搜索了一下无果, 突然想到, 不应该搜索65536, 这个是Page size, 其他人应该是4096 Byte, 是否是为了mmap整数页面呢? 可以测试一下…</p>
<p>分别申请1MB的内存, 然后少申请0~32B的空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">33</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, -i);</span><br><span class="line">        <span class="built_in">malloc</span>(<span class="number">1024</span>*<span class="number">1024</span> - i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后可以使用<code>strace</code>来看申请的内存, 发现申请的内存是<code>1114112B</code>, 比<code>1MB</code>多<code>65536B</code>, 刚好是一个页面, 这也是前面为什么这么多syscall都会mmap一个65535的大小, 但是据说就算malloc不这样做, mmap实际映射时候也会align up到一整个页面. 但是如果申请的内存减少到<code>1MB-24B</code>, 刚好申请的是<code>1MB</code>. 也就是说<code>malloc</code>申请的多了24B, 前面<code>16B</code>, 后面<code>8B</code>.</p>
<p>可以查看一下<a target="_blank" rel="noopener" href="https://codebrowser.dev/glibc/glibc/malloc/malloc.c.html#sysmalloc_mmap">源码</a>…</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">sysmalloc_mmap</span> <span class="params">(INTERNAL_SIZE_T nb, <span class="type">size_t</span> pagesize, <span class="type">int</span> extra_flags, mstate av)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">long</span> <span class="type">int</span> size;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Round up size to nearest page.  For mmapped chunks, the overhead is one</span></span><br><span class="line"><span class="comment">    SIZE_SZ unit larger than for normal chunks, because there is no</span></span><br><span class="line"><span class="comment">    following chunk whose prev_size field could be used.</span></span><br><span class="line"><span class="comment">    See the front_misalign handling below, for glibc there is no need for</span></span><br><span class="line"><span class="comment">    further alignments unless we have have high alignment.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="comment">// MALLOC_ALIGNMENT = (2 * (sizeof (size_t)) &lt; __alignof__ (long double) ? __alignof__ (long double) : 2 * (sizeof (size_t)))</span></span><br><span class="line">   <span class="comment">// CHUNK_HDR_SZ = (2 * (sizeof (size_t)))</span></span><br><span class="line">  <span class="keyword">if</span> (MALLOC_ALIGNMENT == CHUNK_HDR_SZ)</span><br><span class="line">    size = ALIGN_UP (nb + SIZE_SZ, pagesize);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    size = ALIGN_UP (nb + SIZE_SZ + MALLOC_ALIGN_MASK, pagesize);</span><br><span class="line">  <span class="comment">/* Don&#x27;t try if size wraps around 0.  */</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb))</span><br><span class="line">    <span class="keyword">return</span> MAP_FAILED;</span><br><span class="line">  <span class="type">char</span> *mm = (<span class="type">char</span> *) MMAP (<span class="number">0</span>, size,</span><br><span class="line">			    mtag_mmap_flags | PROT_READ | PROT_WRITE,</span><br><span class="line">			    extra_flags);</span><br><span class="line">  <span class="keyword">if</span> (mm == MAP_FAILED)</span><br><span class="line">    <span class="keyword">return</span> mm;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MAP_HUGETLB</span></span><br><span class="line">  <span class="keyword">if</span> (!(extra_flags &amp; MAP_HUGETLB))</span><br><span class="line">    madvise_thp (mm, size);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    The offset to the start of the mmapped region is stored in the prev_size</span></span><br><span class="line"><span class="comment">    field of the chunk.  This allows us to adjust returned start address to</span></span><br><span class="line"><span class="comment">    meet alignment requirements here and in memalign(), and still be able to</span></span><br><span class="line"><span class="comment">    compute proper address argument for later munmap in free() and realloc().</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  INTERNAL_SIZE_T front_misalign; <span class="comment">/* unusable bytes at front of new space */</span></span><br><span class="line">  <span class="keyword">if</span> (MALLOC_ALIGNMENT == CHUNK_HDR_SZ)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* For glibc, chunk2mem increases the address by CHUNK_HDR_SZ and</span></span><br><span class="line"><span class="comment">	 MALLOC_ALIGN_MASK is CHUNK_HDR_SZ-1.  Each mmap&#x27;ed area is page</span></span><br><span class="line"><span class="comment">	 aligned and therefore definitely MALLOC_ALIGN_MASK-aligned.  */</span></span><br><span class="line">      assert (((INTERNAL_SIZE_T) chunk2mem (mm) &amp; MALLOC_ALIGN_MASK) == <span class="number">0</span>);</span><br><span class="line">      front_misalign = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    front_misalign = (INTERNAL_SIZE_T) chunk2mem (mm) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">  mchunkptr p;                    <span class="comment">/* the allocated/returned chunk */</span></span><br><span class="line">  <span class="keyword">if</span> (front_misalign &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">ptrdiff_t</span> correction = MALLOC_ALIGNMENT - front_misalign;</span><br><span class="line">      p = (mchunkptr) (mm + correction);</span><br><span class="line">      set_prev_size (p, correction);</span><br><span class="line">      set_head (p, (size - correction) | IS_MMAPPED);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      p = (mchunkptr) mm;</span><br><span class="line">      set_prev_size (p, <span class="number">0</span>);</span><br><span class="line">      set_head (p, size | IS_MMAPPED);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* update statistics */</span></span><br><span class="line">  <span class="type">int</span> new = atomic_exchange_and_add (&amp;mp_.n_mmaps, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">  <span class="type">atomic_max</span> (&amp;mp_.max_n_mmaps, new);</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> sum;</span><br><span class="line">  sum = atomic_exchange_and_add (&amp;mp_.mmapped_mem, size) + size;</span><br><span class="line">  <span class="type">atomic_max</span> (&amp;mp_.max_mmapped_mem, sum);</span><br><span class="line">  check_chunk (av, p);</span><br><span class="line">  <span class="keyword">return</span> chunk2mem (p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到… 其实大小是allign up到pagesize. 当前环境<code>long double</code>的大小和align都是16B, <code>size_t</code>是8B, 所以应该是<code>size = ALIGN_UP (nb + SIZE_SZ, pagesize);</code>是16B, 但是事实却是24B.</p>
<p>猜测可能是版本的原因, 查看一下glibc的版本, 看到版本是<code>ldd (GNU libc) 2.17</code>, 于是查看<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/glibc/glibc-2.17/source/malloc/malloc.c#L2247">该版本的源码</a>, 发现这部分的内容是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">    size = (nb + SIZE_SZ + pagemask) &amp; ~pagemask;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    size = (nb + SIZE_SZ + MALLOC_ALIGN_MASK + pagemask) &amp; ~pagemask;</span><br></pre></td></tr></table></figure>

<p>就是24B刚好…</p>
<p>那么这24B是拿来干什么的呢, 继续看源码(不要看上面的啦)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = (mchunkptr)mm;</span><br><span class="line"><span class="comment">// #define set_head(p, s)       ((p)-&gt;size = (s))</span></span><br><span class="line">set_head(p, size|IS_MMAPPED);</span><br></pre></td></tr></table></figure>

<p>可以看到在刚mmap的大小上, 存放了大小, 这也就是为什么free可以自动获得大小. 这个位置是8~15B的位置, 也就是我们malloc得到的地址的前面一点点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最后返回<code>chunck2mem</code>的地址, 就是16B的偏执<code>#define chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))</code>, 但是前面的8B和后面的8B都没有提到…在一开始看的版本<code>2.35</code>中是存放了0, 而现在再用的版本似乎没有使用…</p>
<p>然后…是<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/glibc/glibc-2.17/source/malloc/malloc.c#L3240"><code>_int_malloc</code></a>进行的调用…执行的是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="type">void</span> *p = sysmalloc(nb, av);</span><br><span class="line">  <span class="comment">// # define __builtin_expect(expr, val)   (expr)</span></span><br><span class="line">  <span class="comment">// 应该是0</span></span><br><span class="line">  <span class="keyword">if</span> (p != <span class="literal">NULL</span> &amp;&amp; __builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">  <span class="comment">// #define alloc_perturb(p, n) memset (p, (perturb_byte ^ 0xff) &amp; 0xff, n)</span></span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再往外就是内存管理的部分了…也就是说前后8B都没有使用…</p>
<p>我们来测试一下, 是否会如我们想的…打开看一下下面的c程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">void</span> *p = <span class="built_in">malloc</span>(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>, p);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到存放了长度<code>0x11000000000</code>还有一个bit是<code>IS_MMAPPED</code>标志位(0x0002)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x /20xh p-16</span><br><span class="line">0x400000210000:-0x0000  0x0000  0x0000  0x0000  0x0002  0x0011  0x0000  0x0000</span><br><span class="line">0x400000210010: 0x0000  0x0000  0x0000  0x0000  0x0000  0x0000  0x0000  0x0000</span><br><span class="line">0x400000210020: 0x0000  0x0000  0x0000  0x0000</span><br></pre></td></tr></table></figure>

<p>这个确实会影响一些, 比如一开始的时候, First Touch就已经触发了, 第一个页已经确定分配到了主线程所在的Node.</p>
<p>但是其他的按说不会影响太大…虽然每个线程开始的地方不是页面开始的地方, 但是理论上从前到后处理, 应该是不会变化的.</p>
<p>问题依然很难解决, 就先不看这个了…</p>
<h2 id="核心亲和性"><a href="#核心亲和性" class="headerlink" title="核心亲和性"></a>核心亲和性</h2><p>之前说过, 一种常见的应对NUMA的策略就是绑核. 我们设置一下打印出来多线程的核心位置, 计算是为了配合调度这些, 否则分布就更不均匀了, 然后编译<code>gcc -o print_cpu_id -O0 -pthread -lnuma -fopenmp print_cpu_id.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numaif.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numa.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">print_pid</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> threads[<span class="number">128</span>];</span><br><span class="line">    <span class="type">int</span> tid = (<span class="type">int</span>)arg;</span><br><span class="line">    <span class="comment">// sleep(1); </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1e8</span>; ++i);</span><br><span class="line">    <span class="type">int</span> cpu_id = sched_getcpu();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %03d is running on CPU %03d\n&quot;</span>, tid, cpu_id);</span><br><span class="line">    <span class="comment">// sleep(1); </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1e8</span>; ++i);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cpu_id2 = sched_getcpu();</span><br><span class="line">    <span class="keyword">if</span> (cpu_id != cpu_id2) &#123;</span><br><span class="line">        <span class="comment">// 迁移</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; %d \n&quot;</span>, cpu_id, cpu_id2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> num_threads = atoi(argv[<span class="number">1</span>]) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_threads; i++) &#123;</span><br><span class="line">        pthread_create(&amp;threads[i], <span class="literal">NULL</span>, print_pid, (<span class="type">void</span> *)(i + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init(<span class="literal">NULL</span>); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_threads; i++) &#123;</span><br><span class="line">        pthread_join(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后就可以玩啦, <code>./print_cpu_id 1</code>打印主线程, <code>./print_cpu_id 128</code>打印128个线程, 可以看到, 输出的结果非常多, <code>./print_cpu_id 128 | awk &#39;&#123;print $7&#125;&#39; | sort | uniq | wc</code>输出一共124个核心, 可能因为线程的迁移, 所以刚好有些线程在同一个线程, TOP上面看到的其实是128Core都用到了.</p>
<h3 id="taskset和numactl"><a href="#taskset和numactl" class="headerlink" title="taskset和numactl"></a>taskset和numactl</h3><p>taskset是一个最简单的绑核的工具. <code>taskset -c 1 ./print_cpu_id 1</code>打印出来核心在001, 多线程也一样<code> taskset -c 1 ./print_cpu_id 12</code>, 也可以<code>taskset -c 0-11 ./print_cpu_id 12</code></p>
<p>我们试一下strace一下<code>strace taskset -c 4 ./print_cpu_id 1</code>, 发现多了一个syscall, <code>sched_setaffinity(0, 256, [4, ...])     = 0</code>. 其实这个我们自己也可以做.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sched_setaffinity(<span class="number">0</span>, <span class="number">256</span>, [<span class="number">4</span>, ...])     = <span class="number">0</span></span><br><span class="line">execve(<span class="string">&quot;./print_cpu_id&quot;</span>, [<span class="string">&quot;./print_cpu_id&quot;</span>, <span class="string">&quot;1&quot;</span>], <span class="number">0xfffff40806c8</span> <span class="comment">/* 43 vars */</span>) = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>当然可以使用<code>numactl</code>设置亲和性, 比如<code>numactl -C coreid</code>.</p>
<p>此外numactl还可以设置内存分配策略, 比如<code>numactl --interleave=all</code>在不同的node之间分配内存, 拿来测试一下之前的向量加法<code>numactl --interleave=all ./sum  | grep node | awk &#39;&#123;print $11&#125;&#39; | sort | uniq -c</code>, 使用一个线程来初始化, 按照之前的FirstTouch, 应该是都在一个Node上, 但是结果如下, 内存分布在不同的node中, 效果非常好, 效果大概是内存分成了5个部分, 开头和结尾在一个Node, 中间三个段在一个Node. 用时是<code>180648us</code>, 虽然分布更均匀, 但是比128线程初始化来First Touch的效果稍微差不多, 猜测可能是过多访问远端节点造成的.</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">32 0</span><br><span class="line">32 1</span><br><span class="line">32 2</span><br><span class="line">32 3</span><br></pre></td></tr></table></figure>

<h3 id="手动设置亲和性"><a href="#手动设置亲和性" class="headerlink" title="手动设置亲和性"></a>手动设置亲和性</h3><p>如果手动调用这个效果也是一样, 不过可能会有额外的开销, 毕竟是在程序载入之后, 而taskset这种就像上面, 在execve之前就进行设置了亲和性</p>
<p>可以设置一个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 放到最开头</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bind_thread_to_core</span><span class="params">(<span class="type">int</span> core_id)</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpuset;</span><br><span class="line"></span><br><span class="line">    thread = pthread_self();</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;cpuset);</span><br><span class="line">    CPU_SET(core_id, &amp;cpuset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// or sched_setaffinity(0, sizeof(cpu_set_t), &amp;cpuset);</span></span><br><span class="line">    pthread_setaffinity_np(thread, <span class="keyword">sizeof</span>(<span class="type">cpu_set_t</span>), &amp;cpuset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后就可以直接<code>bind_thread_to_core(cpu_id)</code>来绑定了, 可以试一下, 这时候每个线程启动时候绑定一个核心就可以完成绑定核心.</p>
<h3 id="OpenMP和MPI绑定核心"><a href="#OpenMP和MPI绑定核心" class="headerlink" title="OpenMP和MPI绑定核心"></a>OpenMP和MPI绑定核心</h3><p>手动设置亲和性是代价比较高的, 而且很不方便, 但是如果是OpenMP和MPI程序来说taskset和numactl也不太起作用, 但是他们提供了自己的绑核机制.</p>
<h4 id="MPI"><a href="#MPI" class="headerlink" title="MPI"></a>MPI</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mpi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">    <span class="type">int</span> rank, size;</span><br><span class="line">    <span class="type">char</span> hostname[MPI_MAX_PROCESSOR_NAME];</span><br><span class="line">    <span class="type">int</span> hostname_len;</span><br><span class="line">    <span class="type">int</span> cpu_id = sched_getcpu();</span><br><span class="line"></span><br><span class="line">    MPI_Init(&amp;argc, &amp;argv);</span><br><span class="line">    MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);</span><br><span class="line">    MPI_Comm_size(MPI_COMM_WORLD, &amp;size);</span><br><span class="line">    MPI_Get_processor_name(hostname, &amp;hostname_len);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Rank %d (out of %d) is running on CPU %d on %s\n&quot;</span>, rank, size, cpu_id, hostname);</span><br><span class="line"></span><br><span class="line">    MPI_Finalize();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>mpicc -o mpi mpic.c</code>编译, 出来之后<code>mpirun -np 128 ./mpi | awk &#39;&#123;print $10&#125;&#39; | sort | uniq | wc</code>, 开启128个线程, 合并相同的cpuid, 然后发现有86个cpu.</p>
<p>mpi的绑核可以通过mpirun时候指定给出, <code>--bind-to &lt;policy&gt;</code>, 策略可以是none, hwthread, core, l1cache, l2cache, l3cache, socket, numa, board, 默认core, 比如<code>mpirun -np 128 ./mpi | awk &#39;&#123;print $10&#125;&#39; | sort | uniq | wc</code>, 得到128个核心都有绑定线程, 但是映射是混乱的, 如果绑定l3, numa或者board就和之前一样了…</p>
<p>也可以和之前一样… <code>--report-bindings</code>设置打印绑定内容, <code>mpirun -np 4 --report-bindings --bind-to socket ./mpi</code>执行结果太长了不展示了…</p>
<p>可以尝试strace一下, 但是由于开启的这个进程只负责屏幕输出, 启动之类的, 所以需要追踪fork, 但是<code>strace -ff -o trace mpirun -np 4 --report-bindings --bind-to socket ./mpi</code>会出现段错误… 同时有太多进程, 会创建大量的<code>trace.$pid</code>, 因此可以创建一个warpper</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">LOGFILE=<span class="string">&quot;strace-<span class="subst">$(hostname)</span>.$$&quot;</span></span><br><span class="line"><span class="built_in">exec</span> strace -o<span class="string">&quot;<span class="variable">$LOGFILE</span>&quot;</span> /home/user/zombie/applications/neontest/mpi</span><br></pre></td></tr></table></figure>

<p>之后设置成可执行, 然后<code>mpirun -np 4 --report-bindings --bind-to socket ./mpi</code>, 看输出的stace, 依然没有<code>sched_setaffinity</code>, 猜测可能是创建之前就设置好了? 但是从<code>sched_getaffinity</code>结果来看, 其亲和性就被设置成第一个socket所有的core(0~63).</p>
<p>上面的这个是绑定策略, 但是线程和核心的映射依然是混乱的. 想要控制内存映射需要使用<code>--map-by &lt;arg&gt;</code>, 参数可以是slot, hwthread, core, L1cache, L2cache, L3cache, socket, numa, board, node, sequential, distance, and ppr… </p>
<p><code> mpirun -np 8 --bind-to core --map-by node ./mpi</code>理论上会把线程按照04, 15, 26, 37这样分配到四个socket中, 并且绑定每个核心. 但是这个还是段错误<code> signal 11 (Segmentation fault: address not mapped to object at address 0x2e392e312d6682)</code>感觉是libc版本的问题, 有时候地址甚至是0x14之类的… 先不管这个了… 之后再研究(#TODO)</p>
<h4 id="OpenMP"><a href="#OpenMP" class="headerlink" title="OpenMP"></a>OpenMP</h4><p>OpenMP的核心绑定其实也很简单… 首先OpenMP的线程其实也只是启动一次, 如果手动绑定线程的分配手动配置亲和性其实就可以了, 但是这个可能会影响调度(瞎说的 #TODO), 并且也会有一点点的开销. 最好就是使用OpenMP的核心绑定.</p>
<p>OpenMP可以使用环境变量或者progma来配置. 就还是使用之前最开始的向量加法的程序来进行输出. MPI是轮询<code>map-by</code>, 然后绑定到上面的某个<code>bind-to</code>集合上, 其实是相当于OpenMP的Spread. OpenMP有spread, close, master, true, numa_domains, ll_caches. Spread就是类似MPI的方式, 但是bind-to都是核心; Close是轮流分配, 分配完一个区域再分配下一个区域; master就是使用主线程来执行. 每一个区域可以是线程, 核心, socket. 绑定的方式可以使用<code>OMP_PROC_BIND</code>指定, 区域可以使用<code>OMP_PLACES</code>来进行指定.</p>
<p>下图是一个4C8T的多线程, <code>OMP_PLACES</code>设置为<code>orce</code>, 那么每个Core有两个线程, 使用<code>spread</code>和<code>close</code>其线程和核心的映射分布如下(方框表示OpenMP Place，数字表示线程ID):</p>
<img src="/2023/NUMA%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8CFirstTouch/bind.png" class="" title="OMP_PROC_BIND">

<p>如果想要更细粒度的绑定, 比如根据LLC之类的, 可以自己配置<code>OMP_PLACES</code>， 比如<code>OMP_PLACES=&quot;&#123;0&#125;,&#123;1&#125;,&#123;2&#125;,&#123;3&#125;&quot;</code>表示4个PLACE, 每一个地方是一个线程, <code>OMP_PLACES=&quot;&#123;0:2&#125;:32:8&quot;</code>表示, 开始是<code>0:2</code>, 0开始的2个线程, 就是0和1, 32表示有32个Places, 就是一共使用了64线程, 8表示间隔, 第一个PLACE是0和1, 第二个是8和9, 以此类推. 也可以组合使用, 比如<code>export OMP_PLACES=“&#123;0&#125;:4:1,&#123;78&#125;:4:1”</code>, 定义了8个Place, 分别是0, 1, 2, 3, 78, 79, 80, 81号线程.</p>
<h2 id="重新回到First-Touch出问题的地方"><a href="#重新回到First-Touch出问题的地方" class="headerlink" title="重新回到First Touch出问题的地方"></a>重新回到First Touch出问题的地方</h2><p>想到可能是再各种地方执行的… 所以… 可能就是很多再Node0上绑定的… 所以使用绑定之后</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ OMP_PROC_BIND=close ./sum  | grep node | awk <span class="string">&#x27;&#123;print $11&#125;&#x27;</span> | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c</span><br><span class="line">     50 0</span><br><span class="line">     32 1</span><br><span class="line">     32 2</span><br><span class="line">     14 3</span><br></pre></td></tr></table></figure>

<p>结果就是这样, 1 2号node始终32, 最后一个node少一些, 偶尔会是32…</p>
<p>而且, 由于每个Node处理自己最近的内存, 所以速度从之前的单个node<code>225930us</code>, 4个Node胡乱分布<code>173465us</code>, 到了现在的<code>91908us</code></p>
<p>其实一开始就想到这个了, 但是没有太注意, 理论上虽然glibc碰了一下内存, 但是也只是开头, 所以不同Node上应该还是32…</p>
<p>仔细看一下<code>OMP_PLACES=cores OMP_PROC_BIND=close ./sum  | grep node | sort -k 2n</code>, 就会发现, 最后一部分的不符合预期, 所以是glib的最后一部分被一些什么东西碰到了?</p>
<p>之前看malloc的部分代码, 但是也不能确定是在哪里碰到了这个代码, 只能确定开头的16B有写入了一些数据, 最后的8B也不知道, 并且在gdb中看到也是00.</p>
<p>尝试反过来初始化一下, 即每个线程都反过来从后往前初始化, 下标改为<code>len - 1 - i</code>, 发现…开头又又好多页面在Node0上… 所以是First Touch的尺度不是Page? 或者Malloc其实做了一些其他的比如设置保护之类的?</p>
<p>不管了先排除malloc的作用, 把malloc换成mmap:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data_type *a = mmap(<span class="literal">NULL</span>, mem_size, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);<span class="comment">//malloc(mem_size);</span></span><br><span class="line">data_type *b = mmap(<span class="literal">NULL</span>, mem_size, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);<span class="comment">//malloc(mem_size);</span></span><br><span class="line">data_type *c = mmap(<span class="literal">NULL</span>, mem_size, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);<span class="comment">//malloc(mem_size);</span></span><br><span class="line">munmap(a, mem_size);</span><br><span class="line">munmap(b, mem_size);</span><br><span class="line">munmap(c, mem_size);</span><br></pre></td></tr></table></figure>

<p>重新绑核运行, 规规整整的, 和预想的一样. </p>
<h2 id="更诡异的事情"><a href="#更诡异的事情" class="headerlink" title="更诡异的事情"></a>更诡异的事情</h2><p>哪到底是glibc的哪些行为导致了first touch提前生效呢? 开始怀疑First touch是不是以页面为单位的(虽然文档里这么讲的, 看源码又太麻烦了， 但还是忍不住怀疑是不是哪里错了). </p>
<p>写一个pthread的程序, 在Node3上执行主线程, mmap分配内存, 然后去触碰中间一个页面的开头的区域, 然后其他的线程在Node0上去触碰所有的内存, 查看一下内存的分布情况(其实仅仅使用一个线程应该也是可以的).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numaif.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bind_thread_to_core</span><span class="params">(<span class="type">int</span> core_id)</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpuset;</span><br><span class="line"></span><br><span class="line">    thread = pthread_self();</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;cpuset);</span><br><span class="line">    CPU_SET(core_id, &amp;cpuset);</span><br><span class="line"></span><br><span class="line">    sched_setaffinity(<span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">cpu_set_t</span>), &amp;cpuset);</span><br><span class="line">    <span class="comment">//pthread_setaffinity_np(thread, sizeof(cpu_set_t), &amp;cpuset);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 65536 * 1024</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> LEN 67108864</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">init</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    bind_thread_to_core(<span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> *s = (<span class="type">char</span> *)arg;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">long</span> i = <span class="number">0</span>; i &lt; LEN; ++i) &#123;</span><br><span class="line">        s[i] = <span class="number">0xff</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    bind_thread_to_core(<span class="number">127</span>);</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="type">char</span> *c = mmap(<span class="literal">NULL</span>, LEN, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">65536</span>; ++i)</span><br><span class="line">        c[i + <span class="number">65536</span> * <span class="number">512</span>] = <span class="number">0xcc</span>;   <span class="comment">// touch 513rd page</span></span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;thread, <span class="literal">NULL</span>, init, (<span class="type">void</span> *)c);</span><br><span class="line">    pthread_join(thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; ++i) &#123;</span><br><span class="line">        <span class="type">char</span> *ptr = c + i * <span class="number">65536</span>;</span><br><span class="line">        <span class="type">int</span> node;</span><br><span class="line">        get_mempolicy(&amp;node, <span class="literal">NULL</span>, <span class="number">0</span>, (<span class="type">void</span> *)ptr, MPOL_F_NODE | MPOL_F_ADDR);</span><br><span class="line">        <span class="keyword">if</span> (node) &#123;</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    munmap(c, LEN);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果就是只有512是在3号Node上… 是以页面为单位… First touch没问题</p>
<p>诡异的事情来了, 我就要把锅扣到malloc时候, 突然想到, 再看一下源码, 重新打开源码, 找了一圈也没有找到… 改成malloc, 变成了0, 512, 513是在Node3上, 这个和我们预想的完全一样…</p>
<p>问题到底在哪里? 已知:</p>
<ul>
<li>malloc过程中只碰前16B</li>
<li>mmap完全不碰</li>
<li>first touch是以页面为单位的</li>
<li>malloc&#x2F;mmap + pthread在两个线程时候完全正常.</li>
<li><strong>malloc + opemmp开头和结尾会被分配到主线程所在node</strong></li>
<li>mmap + openmp开头和结尾是正常的</li>
</ul>
<p>那就是malloc+openmp会出现一些怪东西, 触发了First touch. 是OpenMP+glibc出现了这个问题?</p>
<p>这就watch一下这一段内存, 之前不这样做主要原因是以为是malloc自己的锅, 那这样想要监视这段地址, 就需要调试glibc, mmap拿到地址之后监视内存访问. 但是从之前的分析, malloc本身是正常的, 那就可以malloc之后再监视最后的一段内存…</p>
<h3 id="GDB调试"><a href="#GDB调试" class="headerlink" title="GDB调试"></a>GDB调试</h3><p>使用gdb进行调试…</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b 18</span><br><span class="line">r</span><br><span class="line">watch *(char [16]*)0x400080330000</span><br><span class="line">c</span><br></pre></td></tr></table></figure>

<p>试了试watch和rwatch(按说读取不会触发)都没看到访问最后的那一个页面… 如果设置成65536速度又会非常非常慢…</p>
<p>想到一些通过设置权限来捕捉内存访问, 那就把a整个数组全都设置成不可读, 不可写<code>call mprotect(0x400000340000, 2147483648, 0)</code></p>
<p>但是continue捕捉到的是a再赋值的时候…</p>
<p>这就非常奇怪了…为什么会在赋值语句才访问到… 但是被其他人碰过, <code>call mprotect(0x400080340000, 65536, 0)</code>看一下最后一个页面, 发现<code>info threads</code>显示就是第128个线程访问的… 这也…</p>
<p>后面rw是正常, malloc不会rw访问后面的这些应用…</p>
<p>那为什么first touch会这么异常…如果是一些类似<code>mprotect</code>这些也不会影响, 而且我的里面没有看到有这个… 真的好怪异… 除了OpenMP+malloc似乎就没有其他的有问题… 当然我这里都是只检查了开头的地址, 可能有一些其他的异常的没有发现</p>
<h3 id="诡异到放弃"><a href="#诡异到放弃" class="headerlink" title="诡异到放弃"></a>诡异到放弃</h3><p>手动模拟malloc进行mmap分配也会观察到类似的malloc相同特征, 本来规规整整的First touch, 突然内存尾部多了好多分配在主节点的内存…</p>
<p>并且… 如果使用mmap分配规整的一大块内存, 使用128线程来初始化是正常的, 但是使用4线程初始化也会出现类似更加严重的现象</p>
<p>所以怀疑是内存分配策略做了一些优化之类的… 测试到发现… 似乎… 更诡异了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numaif.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bind_thread_to_core</span><span class="params">(<span class="type">int</span> core_id)</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpuset;</span><br><span class="line"></span><br><span class="line">    thread = pthread_self();</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;cpuset);</span><br><span class="line">    CPU_SET(core_id, &amp;cpuset);</span><br><span class="line"></span><br><span class="line">    sched_setaffinity(<span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">cpu_set_t</span>), &amp;cpuset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 * 1024 * 1024 * 1024</span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> LEN = <span class="number">4294967296UL</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">init</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    bind_thread_to_core(<span class="number">69</span>);</span><br><span class="line">    <span class="type">char</span> *s = (<span class="type">char</span> *)arg;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">long</span> i = <span class="number">0</span>; i &lt; LEN; ++i) &#123;</span><br><span class="line">        s[i] = <span class="number">0xff</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    bind_thread_to_core(<span class="number">127</span>);</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="type">char</span> *c = <span class="built_in">malloc</span>(LEN);</span><br><span class="line">    <span class="comment">//char *c = mmap(NULL, LEN, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>*<span class="number">65536</span>; ++i) c[<span class="number">16</span> + i + <span class="number">65536</span> * <span class="number">512</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">65536</span>*<span class="number">16</span>; ++i) c[<span class="number">16</span> + i + <span class="number">65536</span> * (<span class="number">512</span> + <span class="number">19</span>)] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;thread, <span class="literal">NULL</span>, &amp;init, (<span class="type">void</span> *)c);</span><br><span class="line">    ret = pthread_join(thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; LEN/<span class="number">65536</span>; ++i) &#123;</span><br><span class="line">        <span class="type">char</span> *ptr = c + i * <span class="number">65536</span>;</span><br><span class="line">        <span class="type">int</span> node;</span><br><span class="line">        get_mempolicy(&amp;node, <span class="literal">NULL</span>, <span class="number">0</span>, (<span class="type">void</span> *)ptr, MPOL_F_NODE | MPOL_F_ADDR);</span><br><span class="line">        <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, i, node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(c);</span><br><span class="line"> <span class="comment">//   munmap(c, LEN);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码… 最后是检测有没有什么是在Node0, 输出很诡异…</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">65486 0</span><br><span class="line">65488 0</span><br><span class="line">65489 0</span><br><span class="line">65493 0</span><br><span class="line">65498 0</span><br><span class="line">65499 0</span><br><span class="line">65502 0</span><br><span class="line">65527 0</span><br><span class="line">65531 0</span><br><span class="line">65532 0</span><br><span class="line">65534 0</span><br><span class="line">65535 0</span><br></pre></td></tr></table></figure>

<p>突然意识到… 这两个… 主线程first touch的是在Node3, 另一个线程是在Node2, 但是出现了若干段Node0上的空间… 已经彻底无法理解这个过程了…</p>
<p>感觉是Linux内存分配策略的问题… 已经不想去看了…</p>
<h3 id="libnuma"><a href="#libnuma" class="headerlink" title="libnuma"></a>libnuma</h3><p>我想要控制NUMA的内存分配位置, 首先就是可以使用一些libnuma提供的接口, 比如<code>numa_alloc_onnode</code>来指定分配的节点, <code>numa_free</code>来释放.</p>
<p>让笨蛋ChatGPT来帮我写一段代码, 两个线程分别来处理一个vector, 求得加法总和之后加到一起. ChatGPT写出来如下代码(当然一开始也是全都是Bug, 而且也只能看看怎么使用):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numa.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SIZE = <span class="number">100000000</span>; <span class="comment">// 100 million</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> HALF = SIZE / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sum</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; data, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">long</span> <span class="type">long</span>&amp; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">        result += data[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size, <span class="type">int</span> node)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;newing &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">void</span>* ret = <span class="built_in">numa_alloc_onnode</span>(size, node);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Custom delete operator</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* memory, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> size)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Delete &quot;</span> &lt;&lt; size &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">numa_free</span>(memory, size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">numa_available</span>() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;NUMA not supported&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt;* data = <span class="built_in">new</span>(<span class="number">0</span>) std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(SIZE, <span class="number">1</span>);</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> result1 = <span class="number">0</span>, result2 = <span class="number">0</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;starting threads&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([=, &amp;result1] &#123; numa_run_on_node(<span class="number">0</span>); sum(*data, <span class="number">0</span>, HALF, result1); &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([=, &amp;result2] &#123; numa_run_on_node(<span class="number">1</span>); sum(*data, HALF, SIZE, result2); &#125;)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;waiting threads&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; result1 + result2 &lt;&lt; std::endl;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(data, <span class="keyword">sizeof</span>(std::vector&lt;<span class="type">int</span>&gt;))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译使用<code>g++ -o numa -pthread -lnuma -O0 -std=c++11 numa.cpp</code></p>
<p>GPT写的这个笨蛋代码, 是内存感知分配了, 但是分配了个皮(vector类本身的24Byte), vector的内存分配还是默认策略, 而且vector还在一个地方(vector持有的空间其实也是), 线程却在在两个Node中间. <strong>基本上就是看个怎么用, 是NUMA感知的负优化</strong>.</p>
<p>不过大概知道怎么用就好了…</p>
<h2 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h2><p>总是写得非常长, 又臭又长, 其实本来像是写一下如何让vector不初始化来使用, 以及如何调用私有函数这些… </p>
<p>但是写的时候介绍背景就已经很长了, 想先写First Touch来配置内存分布, 然后Bind Core会更优化.</p>
<p>就这样写到一半的时候发现First touch不是总是起作用, 猜测是glibc再内存做了一些标注; 之后查看syscall什么也没发现, 但是发现mmap申请的空间其实是比malloc更大的; 然后又去看malloc的mmap的实现, 最后搞清楚了实现.</p>
<p>但是实现只能说明第一个页面的问题, 后面的页面NUMA的分配更诡异…从一开始用gdb改内存页权限, 到最后什么也没发现, 测试了一下其他的程序, 彻底无法理解…也没有找到相关的问题讨论或者文档说明… 感觉需要去看Linux怎么实现的这部分, 或者用一些其他的Debug的方式来监控页面实际的分配过程…</p>
<p>整个过程感觉很是难受… 并且这个环境中OMPI也经常出问题… 感觉可能和glibc有关, 也没时间想… 写下来也是自己都看不懂</p>
<p>后面有时间再看一下具体的分配策略代码实现…还有libc中malloc其他部分的实现…</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="NUMA-1"><a href="#NUMA-1" class="headerlink" title="NUMA"></a>NUMA</h3><ul>
<li>Xia, Jing, et al. “Kunpeng 920: The first 7-nm chiplet-based 64-core arm soc for cloud services.” IEEE Micro 41.5 (2021): 67-75.</li>
<li>Liu, Xu, and John Mellor-Crummey. “A tool to analyze the performance of multithreaded programs on NUMA architectures.” ACM Sigplan Notices 49.8 (2014): 259-272.</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/343661117">原来cpu是这样访问内存的-cpu的NUMA浅析</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_16099276/6902805">numa架构 numa架构设计要点</a></li>
<li><a target="_blank" rel="noopener" href="https://sukihiro.cn/2020/03/25/numa-os-part2/">操作系统对NUMA支持情况：OS部分</a></li>
<li><a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/v5.10/admin-guide/mm/numaperf.html">The Linux kernel user’s and administrator’s guide - NUMA Locality</a></li>
<li><a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/admin-guide/mm/numa_memory_policy.html">NUMA Memory Policy - Linux Kernel Documentation</a></li>
<li><a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man3/numa.3.html">NUMA3 - man7</a></li>
<li><a target="_blank" rel="noopener" href="https://queue.acm.org/detail.cfm?id=2513149">NUMA (Non-Uniform Memory Access): An Overview - ACM queue</a></li>
<li><a target="_blank" rel="noopener" href="https://linux.die.net/man/8/numad">NUMAD(8) - Linux man page</a></li>
</ul>
<h3 id="First-Touch"><a href="#First-Touch" class="headerlink" title="First Touch"></a>First Touch</h3><ul>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/49105427/c-numa-optimization">C++ NUMA Optimization - StackOverflow</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/72055210/openmp-array-initialization-impact">OpenMP array initialization impact - StackOverflow</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/11576670/in-an-openmp-parallel-code-would-there-be-any-benefit-for-memset-to-be-run-in-p">In an OpenMP parallel code, would there be any benefit for memset to be run in parallel? - StackOverflow</a></li>
<li>Trindade, Rafael Gauna, João VF Lima, and Andrea Schwertner Charão. “A Memory Affinity Analysis of Scientific Applications on NUMA Platforms.” 2021 International Symposium on Computer Architecture and High Performance Computing Workshops (SBAC-PADW). IEEE, 2021.</li>
</ul>
<h3 id="Malloc"><a href="#Malloc" class="headerlink" title="Malloc"></a>Malloc</h3><ul>
<li><a target="_blank" rel="noopener" href="https://www.gnu.org/software/libc/manual/html_node/The-GNU-Allocator.html">3.2.2 The GNU Allocator - GNU</a></li>
<li><a target="_blank" rel="noopener" href="https://sourceware.org/glibc/wiki/MallocInternals">Overview of Malloc - glibc wiki</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/pdv5MMUQ9ACpeCpyGnxb1Q">2万字|30张图带你领略glibc内存管理精髓 - 高性能架构探索</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/163401620?utm_id=0">分析 Glibc 中的malloc&#x2F;free 实现 - 知乎</a></li>
<li><a target="_blank" rel="noopener" href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/?blogsub=confirming#subscribe-blog%E3%80%82">Understanding glibc malloc - sploitfun</a>(<a target="_blank" rel="noopener" href="https://blog.csdn.net/maokelong95/article/details/51989081">中文</a>)</li>
<li><a target="_blank" rel="noopener" href="https://csstormq.github.io/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AF%87%E4%B9%8B%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%EF%BC%884%EF%BC%89%EF%BC%9A%E5%86%8D%E6%8E%A2%20mmap">计算机系统篇之虚拟内存（4）：再探 mmap - csstormq’s github page</a></li>
<li><a target="_blank" rel="noopener" href="https://codebrowser.dev/glibc/glibc/malloc/malloc.c.html">Malloc Source Code - Codebrowser</a></li>
<li><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/glibc/glibc-2.17/source/malloc/malloc.c">Malloc Source Code 2.17 - Bootlin</a></li>
</ul>
<h3 id="Bind-Core"><a href="#Bind-Core" class="headerlink" title="Bind Core"></a>Bind Core</h3><ul>
<li><a target="_blank" rel="noopener" href="https://lab.cs.tsinghua.edu.cn/hpc/doc/faq/binding/#openmp">进程绑定 - 高性能计算导论实验文档</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ibm.com/docs/en/xl-fortran-linux/16.1.0?topic=openmp-omp-proc-bind">OMP_PROC_BIND - IBM Documentation</a></li>
<li><a target="_blank" rel="noopener" href="https://hpc-wiki.info/hpc/Binding/Pinning">Binding&#x2F;Pinning - HPCWiki</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/cd/E60778_01/html/E60751/goztg.html">OMP_PLACES and OMP_PROC_BIND - Oracle</a></li>
<li><a target="_blank" rel="noopener" href="https://www.openmp.org/wp-content/uploads/SC18-BoothTalks-vanderPas.pdf">How To Befriend NUMA - OpenMP</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.rwth-aachen.de/itc-events/files/2021/02/13-openmp-CT-NUMA.pdf">Programming OpenMP - NUMA - Christian Terboven</a></li>
</ul>
<h3 id="libnuma-1"><a href="#libnuma-1" class="headerlink" title="libnuma"></a>libnuma</h3><ul>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/7986903/can-i-get-the-numa-node-from-a-pointer-address-in-c-on-linux">StackOverflow - Can I get the NUMA node from a pointer address (in C on Linux)?</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/memory/new/operator_delete">Cppreference - operator delete, operator delete[]</a>.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zombie12138.github.io/2023/Peterson%E7%AE%97%E6%B3%95%E4%B9%8B%E4%B8%80--%E5%9C%A8So%E4%B8%AD%E4%BA%92%E6%96%A5%E8%AE%BF%E9%97%AE%E5%8F%98%E9%87%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zombie12138">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zombie's">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/Peterson%E7%AE%97%E6%B3%95%E4%B9%8B%E4%B8%80--%E5%9C%A8So%E4%B8%AD%E4%BA%92%E6%96%A5%E8%AE%BF%E9%97%AE%E5%8F%98%E9%87%8F/" class="post-title-link" itemprop="url">Peterson算法之一--在So中互斥访问变量</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-03 20:55:35" itemprop="dateCreated datePublished" datetime="2023-08-03T20:55:35+08:00">2023-08-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-08 12:25:24" itemprop="dateModified" datetime="2023-10-08T12:25:24+08:00">2023-10-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前面试某公司的暑期实习, 聊到共享库的时候, 面试官问了一个问题:</p>
<blockquote>
<p>我们现在遇到一个问题, 在SO中共享一个全局变量, 我们想要互斥访问这个全局变量, 应该怎么做?</p>
</blockquote>
<p>自己想的肯定是互斥加锁就可以了, 肯定有对应的系统调用, 但是面试官坚持说如果没有现成的互斥锁应该如何访问共享的变量? 只记得操作系统课程中讲过软件实现互斥锁的算法,<br>但是忘记了最终的实现, 甚至忘记了算法名字…</p>
<p>这个可以拆成几个问题</p>
<ol>
<li>So中如何共享一个变量</li>
<li>有哪些机制可以实现互斥访问</li>
<li>Peterson算法的实现</li>
</ol>
<p>这个问题比较简单(虽然没怎么回答好就是了), 但是可以学习的地方有很多, 这一章先来讨论So中如何互斥地共享某个变量. 如何多进程中互斥.</p>
<p>所有的代码参见我的<a target="_blank" rel="noopener" href="https://github.com/zombie12138/SharedMemoryMutexExample">仓库</a>, 使用的是腾讯云4C4G的轻量应用服务器(KVM over Intel Xeon Gold 6133 CPU)</p>
<h2 id="So的全局变量是共享的吗？"><a href="#So的全局变量是共享的吗？" class="headerlink" title="So的全局变量是共享的吗？"></a>So的全局变量是共享的吗？</h2><p>其实也说不上共享, 是Copy On Write. 写一个共享库, 然后开两个进程去分别初始化和读取, 如果可以读取到对方的写入就说明是共享的, 否则就不是.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">process A.init &amp;&amp; wait keyboard</span><br><span class="line">process B.print()</span><br><span class="line">process B.init &amp;&amp; wait keyboard</span><br><span class="line"></span><br><span class="line">continue A &amp; B</span><br><span class="line"></span><br><span class="line">process A.print()</span><br><span class="line">process B.print()</span><br></pre></td></tr></table></figure>

<p>最终的结果是第一个<code>B.print</code>什么都没有输出, 即A的初始化对B无效; 后面A和B的输出也都是自己本身的内容.</p>
<p>也就是说面试官描述是不准确的, SO中的全局变量是无法共享的（</p>
<p>如果有能力可能会继续剖析动态链接器在这方面的实现.</p>
<h2 id="SO中使用共享的变量"><a href="#SO中使用共享的变量" class="headerlink" title="SO中使用共享的变量"></a>SO中使用共享的变量</h2><p>如果想要共享一些变量, 使用mmap来映射一段共享内存就可以了.</p>
<p>现在so全局变量中定义一下标识符和内存指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SHM_NAME <span class="string">&quot;/shared_memory&quot;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SharedData</span> &#123;</span><br><span class="line">    <span class="type">int</span> counter;</span><br><span class="line">    <span class="type">int</span> wakeup;</span><br><span class="line">    <span class="type">int</span> finished[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> shm_fd;</span><br><span class="line">SharedData *shared_data;</span><br></pre></td></tr></table></figure>

<p>打开共享内存, 设置大小, 映射到内存空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shm_fd = <span class="built_in">shm_open</span>(SHM_NAME, O_CREAT | O_RDWR, <span class="number">0666</span>);</span><br><span class="line"><span class="built_in">ftruncate</span>(shm_fd, <span class="built_in">sizeof</span>(SharedData));</span><br><span class="line">shared_data = <span class="built_in">static_cast</span>&lt;SharedData*&gt;(<span class="built_in">mmap</span>(<span class="number">0</span>, <span class="built_in">sizeof</span>(SharedData), PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, <span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p>最终关闭时候顺序相反</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">munmap</span>(shared_data, <span class="built_in">sizeof</span>(SharedData));</span><br><span class="line"><span class="built_in">close</span>(shm_fd);</span><br><span class="line"><span class="built_in">shm_unlink</span>(SHM_NAME);</span><br></pre></td></tr></table></figure>

<p>来测试一个加法, 访问counter, wakeup用来唤醒初始化之后等待的程序(semaphore的作用). 等待结束也是使用两个int来检查即可.</p>
<p>大概的流程是这样的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">program1 init &amp; wait</span><br><span class="line">start program2 &amp; wakeup program1</span><br><span class="line"></span><br><span class="line">Increase shared int together</span><br><span class="line"></span><br><span class="line">wait for the other to finish</span><br><span class="line">check whether the int value == 1e6</span><br></pre></td></tr></table></figure>

<p>具体来说是通过给Program A添加一个参数, 来设置不同的进程编号, 这就是部分Makefile</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : run cleanp</span><br><span class="line"><span class="section">run:</span></span><br><span class="line">    <span class="comment"># A</span></span><br><span class="line">	@LD_LIBRARY_PATH=./:$LD_LIBRARY_PATH ./program KILL_THIS_THREAD 2&gt;&amp;1 &gt; /dev/null &amp;</span><br><span class="line">    <span class="comment"># B</span></span><br><span class="line">	-@LD_LIBRARY_PATH=./:$LD_LIBRARY_PATH time ./program</span><br><span class="line">	@make cleanp</span><br><span class="line"><span class="section">cleanp:</span></span><br><span class="line">	@ps -aux | grep &#x27;KILL_THIS_THREAD&#x27; | grep -v grep | awk &#x27;&#123;print $$2&#125;&#x27; | xargs -r kill</span><br></pre></td></tr></table></figure>

<p>每个进程进行5e6次加法, 如果正常会得到1e6的结果</p>
<p>最终得到的结果集中在6e6到7e6附近, 用时<code>0.07s</code>. 也就是说确实可以共享, 但也需要一个锁来进行互斥访问变量.</p>
<p>这就回到面试官的问题了, 如何互斥访问</p>
<h2 id="使用信号量"><a href="#使用信号量" class="headerlink" title="使用信号量"></a>使用信号量</h2><p>这个其实就是多进程中的加锁, 可以直接使用信号量或者锁来进行进行互斥访问</p>
<p>可以使用Linux的<code>&lt;semaphore.h&gt;</code>中的<code>sem_t</code>来进行互斥访问, 顺便把wakeup和finished也用信号量来进行实现的(语义会明确些).</p>
<p>Program A初始化时候</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init</span></span><br><span class="line">shared_data-&gt;counter = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">sem_init</span>(&amp;shared_data-&gt;mutex, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">sem_init</span>(&amp;shared_data-&gt;wakeup, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">sem_init</span>(&amp;shared_data-&gt;finished[<span class="number">0</span>], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">sem_init</span>(&amp;shared_data-&gt;finished[<span class="number">1</span>], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// wait program B</span></span><br><span class="line"><span class="built_in">sem_wait</span>(&amp;shared_data-&gt;wakeup);</span><br></pre></td></tr></table></figure>

<p>Program B使用Wakeup信号量唤醒A</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sem_post</span>(&amp;shared_data-&gt;wakeup);</span><br></pre></td></tr></table></figure>

<p>加法就是直接使用信号量实现互斥</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sem_wait</span>(&amp;shared_data-&gt;mutex);</span><br><span class="line">shared_data-&gt;counter++;</span><br><span class="line"><span class="built_in">sem_post</span>(&amp;shared_data-&gt;mutex);</span><br></pre></td></tr></table></figure>

<p>最终结束等待对方的进程, 然后返回结果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pid == 0 or 1</span></span><br><span class="line"><span class="comment">// finished </span></span><br><span class="line"><span class="built_in">sem_post</span>(&amp;shared_data-&gt;finished[pid]);</span><br><span class="line"><span class="comment">// wait</span></span><br><span class="line"><span class="built_in">sem_wait</span>(&amp;shared_data-&gt;finished[<span class="number">1</span> - pid]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get vaule</span></span><br><span class="line"><span class="type">int</span> value = shared_data-&gt;counter;</span><br></pre></td></tr></table></figure>

<p>最终要记得destroy所有信号量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pthread_mutex_destroy</span>(&amp;shared_data-&gt;mutex);</span><br><span class="line"><span class="built_in">sem_destroy</span>(&amp;shared_data-&gt;wakeup);</span><br><span class="line"><span class="built_in">sem_destroy</span>(&amp;shared_data-&gt;finished[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">sem_destroy</span>(&amp;shared_data-&gt;finished[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<p>这次可以得到正确的答案, 但是性能下降了许多, 占用了<code>1.87s</code>, 运行时间提升了25倍以上. 倒也正常, 毕竟又是互斥访问又是系统调用.</p>
<h2 id="更轻量的锁"><a href="#更轻量的锁" class="headerlink" title="更轻量的锁"></a>更轻量的锁</h2><p>使用信号量太笨重了, 每次都要切换内核态和用户态, 所以性能下降如此严重. 不如直接使用多进程的mutex.<br>恰好, pthread提供了一个多进程之间锁的调用</p>
<p>首先把结构体中的互斥锁改成<code>pthread_mutex_t mutex;</code>, 之后初始化为多进程之间的锁</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SharedData</span> &#123;</span><br><span class="line">    <span class="type">sem_t</span> finished[<span class="number">2</span>];</span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="type">sem_t</span> wakeup;</span><br><span class="line">    <span class="type">int</span> counter;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中要初始化为多进程之间的锁</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init</span></span><br><span class="line"><span class="type">pthread_mutexattr_t</span> mutexattr;</span><br><span class="line"><span class="built_in">pthread_mutexattr_init</span>(&amp;mutexattr);</span><br><span class="line"><span class="built_in">pthread_mutexattr_setpshared</span>(&amp;mutexattr, PTHREAD_PROCESS_SHARED);</span><br><span class="line"><span class="built_in">pthread_mutex_init</span>(&amp;shared_data-&gt;mutex,&amp;mutexattr);</span><br><span class="line"><span class="built_in">pthread_mutexattr_destroy</span>(&amp;mutexattr);</span><br></pre></td></tr></table></figure>

<p>使用也很简单</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;shared_data-&gt;mutex);</span><br><span class="line">shared_data-&gt;counter++;</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;shared_data-&gt;mutex);</span><br></pre></td></tr></table></figure>

<p>最终销毁</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pthread_mutex_destroy</span>(&amp;shared_data-&gt;mutex);</span><br></pre></td></tr></table></figure>

<p>这次的结果依然正确, 但是时间下降了接近一半, 只要<code>0.94s</code>, 虽然还是带来了10倍多的overhead, 但是已经快了许多</p>
<p>提速的原因是因为他会先尝试获取用户态的锁, 获取成功就会直接进入, 如果不成功才会使用futex这些系统调用. 这个具体在TODO中进行分析.</p>
<h2 id="使用原子操作"><a href="#使用原子操作" class="headerlink" title="使用原子操作"></a>使用原子操作</h2><p>都这样了, 不如直接使用atomic add来原子加法, 估计会比之前的速度都要更快一些.</p>
<p>可以直接把<code>mutex</code>变量相关的删掉, 把<code>int</code>换成<code>std::atomic_int</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SharedData</span> &#123;</span><br><span class="line">    <span class="type">sem_t</span> finished[<span class="number">2</span>];</span><br><span class="line">    <span class="type">sem_t</span> wakeup;</span><br><span class="line">    std::atomic_int counter;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>运行一下, 只有<code>0.24s</code>, 互斥的overhead已经从之前的25倍以上, 10倍以上, 降低到现在的仅有2倍多, 但是这个其实是有些作弊的, 毕竟这只是一个int的value</p>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>原子操作台作弊了, 就用自旋锁, 比较轻量, 应该是最快的了</p>
<p>首先是定义(依然在之前的结构体中), 初始化和销毁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_spinlock_t</span>  mutex;</span><br><span class="line"></span><br><span class="line">pthread_spin_init(&amp;spin, PTHREAD_PROCESS_SHARED);</span><br><span class="line">pthread_spin_destroy(&amp;spin);</span><br></pre></td></tr></table></figure>

<p><code>PTHREAD_PROCESS_SHARED</code>表示是多进程共享的, 如果仅仅是多线程只需要<code>PTHREAD_PROCESS_PRIVATE</code>.</p>
<p>加锁, 去锁也很简单</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pthread_spin_lock(&amp;shared_data-&gt;mutex);</span><br><span class="line">pthread_spin_unlock(&amp;shared_data-&gt;mutex);</span><br></pre></td></tr></table></figure>

<p>最后结果非常Amazing, <code>0.17s</code>就得到了正确结果, 可以做到比原子操作更快.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>多进程访问so中的global variable不会共享, 可以使用mmap来映射一段共享内存. 互斥访问就是多进程中的互斥, 分别使用了信号量(1.87s), 互斥锁(0.94s), 原子操作(0.24s), 自旋锁(0.17s)解决了问题, 但是依然有很多疑问:</p>
<ul>
<li>如何不使用额外的命令行参数, 自动 安全 优雅地为进程分配编号?</li>
<li>这些调用背后做了哪些工作, 为什么差别这么大? 自旋锁为什么比原子操作还要快.</li>
<li>还有就是最初的问题还是没有解决, 就是如何实现Peterson算法, 如何在现代计算机中如何实现Peterson算法?</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://unix.stackexchange.com/questions/478533/why-are-program-images-and-shared-libraries-considered-private-to-a-process">Why are “program images and shared libraries” “considered private to a process” but “shared (SHR) by the kernel”?</a>  </li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/37047977/which-segments-are-affected-by-a-copy-on-write">Which segments are affected by a copy-on-write?</a>  </li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/5095781/how-pthread-mutex-lock-is-implemented">How pthread_mutex_lock is implemented</a>  </li>
<li><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_13267193/5370574">Linux 同步机制：自旋锁</a>  </li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/526524232">面试必备之Linux内核自旋锁</a>  </li>
<li><a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man3/pthread_spin_init.3.html">pthread_spin_init(3) — Linux manual page</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zombie12138.github.io/2023/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zombie12138">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zombie's">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-12 17:14:07" itemprop="dateCreated datePublished" datetime="2023-06-12T17:14:07+08:00">2023-06-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-13 17:09:36" itemprop="dateModified" datetime="2023-10-13T17:09:36+08:00">2023-10-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>. <sup class="refplus-num"><a href="#ref-self">[1]</a></sup></p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<ul id="refplus"><li id="ref-self" data-num="1">[1]  <a href="/2023/hello-world/" title="[hello-world]">[hello-world]</a></li></ul>

    <style>
    #refplus, #refplus li{ 
        padding:0;
        margin:0;
        list-style:none;
    }；
    </style>
    <script src="https://unpkg.com/@popperjs/core@2"></script>
    <script src="https://unpkg.com/tippy.js@6"></script>
    <script>
    document.querySelectorAll(".refplus-num").forEach((ref) => {
        let refid = ref.firstChild.href.replace(location.origin+location.pathname,'');
        let refel = document.querySelector(refid);
        let refnum = refel.dataset.num;
        let ref_content = refel.innerText.replace(`[${refnum}]`,'');
        tippy(ref, {
            content: ref_content,
        });
    });
    </script>
    
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zombie12138</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zombie12138</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
