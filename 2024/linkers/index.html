<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zombie12138.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="在编译的过程中, 你可以使用 make -j 启用并行编译. 但是最终的链接总是非常慢, 默认的 ld 是单线程的, 无法利用多核优势. 修改任何一个文件, 往往都需要修改最后的链接过程 (动态库或最终的可执行文件). 所以有了增量链接和并行链接两种方案. 今天来简单看一下有哪些链接器.">
<meta property="og:type" content="article">
<meta property="og:title" content="并行 &#x2F; 增量链接 -- ld.bfd, ld.gold, lld, mold 的设计">
<meta property="og:url" content="https://zombie12138.github.io/2024/linkers/index.html">
<meta property="og:site_name" content="zombie&#39;s">
<meta property="og:description" content="在编译的过程中, 你可以使用 make -j 启用并行编译. 但是最终的链接总是非常慢, 默认的 ld 是单线程的, 无法利用多核优势. 修改任何一个文件, 往往都需要修改最后的链接过程 (动态库或最终的可执行文件). 所以有了增量链接和并行链接两种方案. 今天来简单看一下有哪些链接器.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zombie12138.github.io/2024/linkers/ldd_sc.png">
<meta property="og:image" content="https://zombie12138.github.io/2024/linkers/cost.png">
<meta property="og:image" content="https://zombie12138.github.io/2024/linkers/hash.png">
<meta property="og:image" content="https://zombie12138.github.io/2024/linkers/cost_after.png">
<meta property="og:image" content="https://zombie12138.github.io/2024/linkers/loc.png">
<meta property="og:image" content="https://zombie12138.github.io/2024/linkers/error.png">
<meta property="og:image" content="https://zombie12138.github.io/2024/linkers/mold.png">
<meta property="og:image" content="https://zombie12138.github.io/2024/linkers/htop.gif">
<meta property="article:published_time" content="2024-05-06T08:33:08.000Z">
<meta property="article:modified_time" content="2025-08-04T17:49:59.916Z">
<meta property="article:author" content="zombie12138">
<meta property="article:tag" content="Compiler">
<meta property="article:tag" content="Survey">
<meta property="article:tag" content="Linker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zombie12138.github.io/2024/linkers/ldd_sc.png">

<link rel="canonical" href="https://zombie12138.github.io/2024/linkers/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>并行 / 增量链接 -- ld.bfd, ld.gold, lld, mold 的设计 | zombie's</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">zombie's</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zombie12138.github.io/2024/linkers/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zombie12138">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zombie's">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          并行 / 增量链接 -- ld.bfd, ld.gold, lld, mold 的设计
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-06 16:33:08" itemprop="dateCreated datePublished" datetime="2024-05-06T16:33:08+08:00">2024-05-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-08-05 01:49:59" itemprop="dateModified" datetime="2025-08-05T01:49:59+08:00">2025-08-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>在编译的过程中, 你可以使用 <code>make -j</code> 启用并行编译. 但是最终的链接总是非常慢, 默认的 ld 是单线程的, 无法利用多核优势. 修改任何一个文件, 往往都需要修改最后的链接过程 (动态库或最终的可执行文件). 所以有了增量链接和并行链接两种方案.</p>
<p>今天来简单看一下有哪些链接器.</p>
<span id="more"></span>

<p>我每一个链接器参考了一篇文章, 对比了 ld.bfd, ld.gold, llvm ld 和 mold. ld.bfd 的太详细, 主要是使用方法, 是一个手册性质的, 因此没有仔细看</p>
<ul>
<li>ld.bfd: <a target="_blank" rel="noopener" href="https://www.eecs.umich.edu/courses/eecs373/readings/Linker.pdf">The GNU Linker</a></li>
<li>ld.gold: <a target="_blank" rel="noopener" href="https://research.google.com/pubs/archive/34417.pdf">A New ELF Linker</a>, <a target="_blank" rel="noopener" href="https://smvv.io/gold.pdf">并行链接</a>, <a target="_blank" rel="noopener" href="https://gcc.gnu.org/wiki/GoldIncrementalLinking">增量链接</a></li>
<li>lld: <a target="_blank" rel="noopener" href="https://llvm.org/devmtg/2017-10/slides/Ueyama-lld.pdf">Slides</a></li>
<li>mold: <a target="_blank" rel="noopener" href="https://github.com/rui314/mold">Design.md</a></li>
</ul>
<h2 id="1-问题"><a href="#1-问题" class="headerlink" title="1 问题"></a><em>1</em> 问题</h2><h3 id="1-1-为什么链接这么慢"><a href="#1-1-为什么链接这么慢" class="headerlink" title="1.1 为什么链接这么慢"></a><em>1.1</em> 为什么链接这么慢</h3><p>编译一个大型项目非常慢, 尤其是 CMake 的编译进度条到最后 99 的时候总是会非常卡, 这是在进行最后的链接过程. 有时候我们仅仅改了一个文件, 但是链接过程可能依然需要花费数分钟.</p>
<p>其实问题也很简单, 因为编译的过程可以看作一个 DAG (有向无环图), 在不同的文件之间, 其编译的过程是相对独立的, 因此不同任务之间是可以并行的. 但是链接过程往往在 DAG 的最后, 进行符号解析, 重定位等操作, 进行单线程处理多个输入文件产出一个最终的 BIN.</p>
<p>每次修改一个文件, 沿着修改文件的 DAG 节点的都需要重新编译, 这个时候最终的往往是一个链接的过程, 并且链接依然需要重新进行, 处理多个输入. 链接过程如果想要并行, 需要链接器内来实现, 并且有很大的难度, 而我们使用的 GNU <code>ld.bfd</code> 是没有并行的.</p>
<p>一个链接的过程可能非常巨大, 例如 <code>mold</code> 后面提供的一个 case:</p>
<table>
<thead>
<tr>
<th>Data item</th>
<th>Number</th>
</tr>
</thead>
<tbody><tr>
<td>Object files</td>
<td>30,723</td>
</tr>
<tr>
<td>Public undefined symbols</td>
<td>1,428,149</td>
</tr>
<tr>
<td>Mergeable strings</td>
<td>1,579,996</td>
</tr>
<tr>
<td>Comdat groups</td>
<td>9,914,510</td>
</tr>
<tr>
<td>Regular sections¹</td>
<td>10,345,314</td>
</tr>
<tr>
<td>Public defined symbols</td>
<td>10,512,135</td>
</tr>
<tr>
<td>Symbols</td>
<td>23,953,607</td>
</tr>
<tr>
<td>Sections</td>
<td>27,543,225</td>
</tr>
<tr>
<td>Relocations against SHF_ALLOC sections</td>
<td>39,496,375</td>
</tr>
<tr>
<td>Relocations</td>
<td>62,024,719</td>
</tr>
</tbody></table>
<h3 id="1-2-怎么加快链接速度"><a href="#1-2-怎么加快链接速度" class="headerlink" title="1.2 怎么加快链接速度"></a><em>1.2</em> 怎么加快链接速度</h3><p>对于编译我们可以并行, 分布式, 增量, 预编译头文件, 分割代码库等.<br>并行和增量这些对于链接器更加困难, 因为编译是一个个相对独立的任务, 只需要同时启动多个任务也能实现并行的效果, 但是链接往往是最终只有一个任务在执行, 需要链接器内部实现.</p>
<p>有问题就一定有办法解决. 这是一个计算机领域常见的问题, 那就一定有人尝试去解决它, 并行和增量链接理论上能实现, 就一定有人尝试实现它.</p>
<h4 id="1-2-1-增量链接"><a href="#1-2-1-增量链接" class="headerlink" title="1.2.1 增量链接"></a><em>1.2.1</em> 增量链接</h4><h5 id="MSVC-link-exe"><a href="#MSVC-link-exe" class="headerlink" title="MSVC link.exe"></a>MSVC link.exe</h5><p>增量链接最直接的例子就是 MSVC 的 <code>link.exe</code>, 开启 <code>/INCREMENTAL</code> 即可启用, 在 Debug 模式下默认开启. 链接器会创建一个 <code>.ilk</code> 文件。这本质上是一个数据库，详细记录了所有输入 <code>.obj</code> 文件的路径和时间戳, 每个 <code>.obj</code> 文件中的函数和数据符号及其地址 以及 最终生成的可执行文件 (<code>.exe</code>&#x2F;<code>.dll</code>) 中每个 section 的虚拟地址和大小. 链接器会在可执行文件中插入 <strong>Padding</strong>会有意地在函数和数据块之间插入一些未使用的空白空间. 这些空间就像是为未来的修改预留的位置.</p>
<p>后续 <code>link.exe</code> 启动时，首先读取 <code>.ilk</code> 文件. 然后它会检查所有输入目标文件的时间戳, 与 <code>.ilk</code> 中记录的时间戳进行比对, 迅速定位被修改过的文件. 对于每个修改过的 .obj 文件，链接器会重新处理.代码变小或大小不变, 则链接器可以直接在 .exe 文件中对应的旧位置就地覆盖 (overwrite) 新的代码. 如果代码变大, 放不进旧位置, 那么后续的 section 的偏移都会受影响. 链接器就会在之前预留的填充位 (padding) 中寻找一个足够大的空间, 将新的、更大的函数代码放置在这个新空间里. 在旧函数的位置, 写入一个非常短的跳转指令 (<code>JMP</code>), 指向新函数的位置. 这个跳转指令被称为 <code>Thunk</code>. 这种处理做法很像是动态链接器的做法.</p>
<p>这种增量链接会影响性能和最终的二进制大小, 因此默认是只有 Debug 会开启. 并且非常容易退化. 例如下面这些情况增量链接都可能退化到全量链接:</p>
<ol>
<li>修改链接的配置和脚本, 这时候链接无法复用之前的结果.</li>
<li>状态文件 <code>.ilk</code> 或者清空重新进行链接.</li>
<li>文件修改范围过大, 例如过半文件都被修改, 或者修改了大量被依赖的全局符号. 这时候增量连接变得异常复杂.</li>
<li>Padding 被用完, 这时候必须对可执行文件 relayout.</li>
</ol>
<h5 id="ld"><a href="#ld" class="headerlink" title="ld"></a>ld</h5><p><code>ld</code> 的增量链接是手动实现的, 其需要使用 <code>-r</code> 或 <code>--relocatable</code>, 将多个 <code>.o</code> 目标文件合并为一个更大的目标文件. 这样下次链接只需要链接一个大的目标文件和变更的小的目标文件. 需要手动管理.</p>
<h5 id="gold-lld"><a href="#gold-lld" class="headerlink" title="gold &amp;&amp; lld"></a>gold &amp;&amp; lld</h5><p><code>gold</code> 只需要 <code>--incremental</code>, 则会在输出文件中保留链接状态, 下次链接仅仅处理变更的文件. <code>gold</code> 也是会在输出文件中嵌入元数据例如 <code>.gnu.gold_incremental_inputs</code>, 所有输入文件的列表及其校验和 (checksum), 完整的符号表信息, 和输出文件的布局信息. 类似的 也会创建 padding 来预防某些输入的目标文件增大.</p>
<p><code>lld</code> 则也是实现了类似的增量, 使用 <code>-r</code>.</p>
<h4 id="1-2-2-并行链接"><a href="#1-2-2-并行链接" class="headerlink" title="1.2.2 并行链接"></a><em>1.2.2</em> 并行链接</h4><p>增量链接过程复杂, 适用范围局限.</p>
<p>对于链接的并行, 这个过程则就没有那么复杂, 并且可以达到非常惊人的速度. 本文后续会重点学习.</p>
<p>Linux 下的链接器很多, 比如 ld.bfd, <a target="_blank" rel="noopener" href="https://research.google.com/pubs/archive/34417.pdf">ld.GOLD</a>, llvm 的 <a target="_blank" rel="noopener" href="https://llvm.org/devmtg/2017-10/slides/Ueyama-lld.pdf">lld</a>, 以及 <a target="_blank" rel="noopener" href="https://github.com/rui314/mold">mold</a>. 这几个的性能是逐渐提升的. 我们分别参考了其中设计的文章或者 Slides, 来分别讨论这几个链接器的设计.</p>
<h2 id="2-LD-BFD"><a href="#2-LD-BFD" class="headerlink" title="2 LD.BFD"></a><em>2</em> LD.BFD</h2><p>这个没有并行链接的支持, 是最经常使用的一个. 但是有手动的增量链接的支持, 这个前面已经讨论, 使用范围非常受限, 只是合并不经常变更的 <code>.o</code>, 减少输入文件数量来提高编译速度, 需要用户手动管理.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* foo.c */</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void foo() &#123;</span><br><span class="line">    printf(&quot;Hello, &quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* bar.c */</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void bar() &#123;</span><br><span class="line">    printf(&quot;world!\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -c foo.c -o foo.o</span><br><span class="line">gcc -c bar.c -o bar.o</span><br><span class="line">ld -r foo.o bar.o  -o partial.o</span><br></pre></td></tr></table></figure>

<h2 id="3-GOLD"><a href="#3-GOLD" class="headerlink" title="3 GOLD"></a><em>3</em> GOLD</h2><p>GOLD 的设计在 <a target="_blank" rel="noopener" href="https://research.google.com/pubs/archive/34417.pdf">&lt;A New ELF Linker&gt;</a> 中讲了很多, 相对于 LD 主要是舍弃了 BFD, 并且添加了多线程的支持 (很少), 以及使用 C++.</p>
<h3 id="3-1-背景"><a href="#3-1-背景" class="headerlink" title="3.1 背景"></a><em>3.1</em> 背景</h3><p>这个是 Google 的人搞出来的, 并且这个人还参与了之前的普通的 ld (bfd) 的贡献. 同样他们举了个例子, GOOGLE 的内部程序, 链接输出超过 700M, 1300 个输入对象, 400000 个全局符号, 编译需要 11 分钟, 其中链接就需要 2 分多钟, 并且是串行的.</p>
<p>之前的 ld.bfd 链接分为以下几个部分:</p>
<ul>
<li>浏览所有输入文件, 识别符号和输入部分</li>
<li>遍历 linker script 链接器标本, 根据每个输入 Section 的名称将其分配给输出 Section</li>
<li>再次浏览链接描述文件，为输出节分配地址</li>
<li>再次遍历输入文件，将输入部分复制到输出文件并应用重定位</li>
</ul>
<p>linker script 是用来控制输出不同 section 的空间布局等信息的, 比如 <code>/usr/lib/x86_64-linux-gnu/libc.so</code> 其实是一个 Linker Script. GNU 的 linker 有默认的 script, 使用 <code>g++ -Wl,--verbose main.cpp</code> 就可以看到.</p>
<p>典型的 ELF linker 要遍历很多很多次符号表, 包括依次执行下面的这些任务 (有的也有点不太清楚具体是什么意思):</p>
<ul>
<li>给符号分配版本号 (Symbol Versioning, <a target="_blank" rel="noopener" href="https://www.cnblogs.com/tsecer/p/10485857.html">符号版本化</a>)</li>
<li>设置动态对象的符号的值</li>
<li>构建 GOT 和 PLT 表</li>
<li>查看是否存在应用于只读 section 的重定位 (未使用 PIC 代码编译, 访问共享库全局变量, 需要修改 .text 的重定位条目)</li>
<li>查找符号版本依赖</li>
<li>计算动态符号的哈希</li>
<li>…</li>
</ul>
<p>有些遍历过程可以进行合并优化, GOLD 的实现仅仅遍历符号表三次.</p>
<p>GNU 的链接器是构建在 BFD (Binary File Descriptor) 库上, 是通过 BFD 链接器符号表上分层实现的, 大多数的 ELF 后端都会在基本 ELF 上添加附加信息. 这些信息会重复并且妨碍对齐优化. 符号表中 (应该是编译中的), gold 相比 BFD, 32bit 系统下条目大小 80B-&gt;48B, 64bit 系统下, 156B-&gt;68B. 分层也会使得 GNU 链接器必须对 ELF 文件中的符号设置版本.</p>
<p>gnu 传统的 ld.bfd 也是 C 语言写的, 链表 -&gt; 哈希表这些数据结构的改变或者自动调整哈希表大小都很困难, 处理大型代码的时候速度很容易非常慢. BFD 也提供了自动调整大小的哈希表, 但是 key 必须是字符串.</p>
<p>这个作者似乎为 ld.bfd 做出了很多贡献, 但是他认为应该重写, 并且抛弃 BFD.</p>
<h3 id="3-2-设计"><a href="#3-2-设计" class="headerlink" title="3.2 设计"></a><em>3.2</em> 设计</h3><h4 id="3-2-1-特性"><a href="#3-2-1-特性" class="headerlink" title="3.2.1 特性"></a><em>3.2.1</em> 特性</h4><h5 id="流程优化"><a href="#流程优化" class="headerlink" title="流程优化"></a>流程优化</h5><p>GOLD 的流程如下:</p>
<ul>
<li>浏览输入文件, 识别符号和输入部分</li>
<li>再次浏览输入文件, 读取重定位并构建 PLT (Procedure Linkage Table) 和 GOT (Global Offset Table)</li>
<li>将输出节分配给输出段, 并将地址分配给输出段</li>
<li>再次遍历输入文件，将输入部分复制到输出文件并应用重定位</li>
</ul>
<p>与 GNU 链接器 ld.bfd 的主要区别在于第二次遍历输入文件以读取重定位, 以及省略了链接器脚本 (ld.bfd 有一个默认的 linker script). 使用二次遍历输入文件来读取重定位可以简化符号处理, 它还避免了遍历符号表. 传统的 ld.bfd 试图一次完成文件遍历, 因此会造成之前说的多次遍历文件符号表:</p>
<ol>
<li>开一个输入文件 (<code>a.o</code>)。</li>
<li>读取它的符号表，并将其合并到一个巨大的 <strong>全局符号表</strong> 中.</li>
<li>读取它的节 (sections), 比如 <code>.text</code> 和 <code>.data</code>.</li>
<li>读取与这些节相关的 <strong>重定位信息</strong> (比如 <code>.rela.text</code>).</li>
<li>对于 <code>.text</code> 中的每一条重定位 (比如一个 <code>call foo</code> 指令), 它都需要知道 <code>foo</code> 的最终地址.</li>
<li>但是 <code>foo</code> 可能定义在尚未读取的 <code>z.o</code> 文件中！</li>
<li><strong><code>ld.bfd</code> 的对策</strong>: 它必须在庞大的全局符号表中<strong>查找</strong> <code>foo</code>.<ul>
<li>如果找到了, 就用那个信息.</li>
<li>如果没找到, 就创建一个 “待定” 条目. 等读到 <code>z.o</code> 并发现 <code>foo</code> 的定义时, 再回来更新这个条目.</li>
</ul>
</li>
<li>这个过程非常复杂. 它需要在整个链接过程中维护一个不断变化的, 需要反复查找和更新的全局符号表. 对于每个重定位. 都可能触发一次复杂的符号表搜索.</li>
</ol>
<p>gold 则是第一次只做符号解析和布局规划, 它读取所有符号 (<code>.symbol</code>) , 并解析它们的定义和引用关系; 同时遍历 section header, 了解每个 section 大小等元数据, 具体的重定位信息和内容不读取. 第二次则是只做重定位和内容拷贝. 它将 <code>a.o</code> 的 <code>.text</code> 内容直接拷贝到输出文件中正确的位置. 重定位信息 (<code>.rela.text</code>): 它读取重定位条目. 当它处理 <code>call foo</code> 这条重定位时, 它不再需要去搜索符号表了, 因为它已经完成了一次完整的遍历, 已经知道包括 <code>foo</code> 的每个符号的确切最终地址.</p>
<h5 id="省略默认链接器脚本与动态布局"><a href="#省略默认链接器脚本与动态布局" class="headerlink" title="省略默认链接器脚本与动态布局"></a>省略默认链接器脚本与动态布局</h5><p>ld.bfd 的行为在很大程度上是由一个链接器脚本 (linker script) 控制的. 即使不提供, 它也会使用一个内置的默认脚本. 这个脚本会 <strong>预先规定输出文件的结构</strong>. 例如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">  . = <span class="number">0x400000</span>;          <span class="comment">/* 地址从这里开始 */</span></span><br><span class="line">  .text : &#123; *(.text) &#125;  <span class="comment">/* 所有输入文件的 .text 节都放在这里 */</span></span><br><span class="line">  .rodata : &#123; *(.rodata) &#125; <span class="comment">/* 所有 .rodata 节放在这里 */</span></span><br><span class="line">  <span class="comment">/* ... 等等 ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>gold</code> 放弃了这种僵化的默认脚本, 选择让输入文件自己来决定输出文件的布局.</p>
<p>可以在读取输入节时将其分配给输出节: 在第一次遍历时, <code>gold</code> 看到 <code>a.o</code> 有一个 <code>.text</code> 节, 它就在内部创建一个最终输出的 <code>.text</code> 聚合区，并把 <code>a.o</code> 的 <code>.text</code> 登记进去. 当它看到 <code>b.o</code> 的 <code>.text</code> 时, 也将其登记到同一个聚合区. 它不是根据脚本指令, 而是根据输入节本身的名字和属性来动态地创建和填充这些输出聚合区.</p>
<p>输出节可以根据其类型和标志 (rwx) 分组为输出段: 在第一次遍历结束后, <code>gold</code> 有了所有的输出节聚合区 (比如一个大的 <code>.text</code>, 一个大的 <code>.data</code> 等). 现在, 它可以根据这些节的属性来组织最终的程序映像 (segments).</p>
<p>所有只读、可执行 (r-x) 的节 (如 <code>.text</code>, <code>.init</code>, <code>.fini</code>) 被自然地组合在一起，形成一个 <code>LOAD</code> 段 (Segment).所有只读、不可执行 (r–) 的节 (如 <code>.rodata</code>) 被组合在一起, 形成另一个 <code>LOAD</code> 段. 所有可读、可写 (rw-) 的节 (如 <code>.data</code>, <code>.bss</code>) 被组合在一起，形成第三个 <code>LOAD</code> 段。</p>
<p>这种布局方式是自底向上, 输入驱动. 而不是像 <code>ld.bfd</code> 那样自顶向下, 脚本规定的. 这不仅更简单灵活, 而且通常能产生 <strong>更紧凑, 更合理的内存布局</strong>.</p>
<p>总的来说由于没有默认的链接描述文件, 因此可以在读取输入节时将其分配给输出节. 输出节可以根据其类型和标志 (rwx) 分组为输出段, 而不是根据链接描述文件中设置的地址.</p>
<h4 id="3-2-2-多线程"><a href="#3-2-2-多线程" class="headerlink" title="3.2.2 多线程"></a><em>3.2.2</em> 多线程</h4><p><code>Gold</code> 是多线程的, 但是这个多线程的部分非常有限, 目的是允许链接器重叠 IO 密集任务 (磁盘操作) 和 CPU 任务. 链接过程被分成任务, 组织成一个 DAG, 细粒度的锁很少, 工作线程池会在任务可用时获取任务. 作者认为: <strong>实践中并没有证明使用多线程可以显着提高性能, 在某些情况下这是一个微小的改进, 在另一些情况下则是轻微的放缓</strong>, 以至于作者认为可能是实现错误. 但是后面被 <code>lld</code> 和 <code>mold</code> 打脸了.</p>
<h4 id="3-2-3-采用-C-模板特化进行优化"><a href="#3-2-3-采用-C-模板特化进行优化" class="headerlink" title="3.2.3 采用 C++ 模板特化进行优化"></a><em>3.2.3</em> 采用 C++ 模板特化进行优化</h4><p><code>Gold</code> 使用模板特化来实现 byte swap, 任何从输入文件读取链接信息的函数, 例如 section headers 等, 都是为基于输出的 ELF 文件的类的模板. 在不同的机器 (大小端) 上执行不同的代码.</p>
<p>用了 22 中不同的哈希, 有多种不同的 Key 的类型, 并且添加哈希表很容易.</p>
<h4 id="3-2-4-Merge-Sections"><a href="#3-2-4-Merge-Sections" class="headerlink" title="3.2.4 Merge Sections"></a><em>3.2.4</em> Merge Sections</h4><p><code>SHF_MERGE</code> 表示, 这个 section 里面的内容是一些大小固定的条目, 并且这些条目中可能存在大量重复, 需要进行合并 (String Merging). 这个合并部分是耗时最长的操作之一. 文中说这个是包含一些常量, 比如字符串常量 (跨多个文件, 可能每个文件都有 <code>&quot;hello&quot;</code>), 但是这个似乎和 <code>COMDAT</code> 的还不一样, <code>COMDAT</code> 主要是可以合并的函数 (Function&#x2F;Data Deduplication).</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">readelf -WS a.o</span><br><span class="line">File: a.o</span><br><span class="line">There are 18 section headers, starting at offset 0x328:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al</span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 6] .rodata           PROGBITS         0000000000000000  0000006b</span><br><span class="line">       0000000000000005  0000000000000000   A       0     0     1</span><br><span class="line">  [ 9] .text._Z3add[...] PROGBITS         0000000000000000  00000078</span><br><span class="line">       0000000000000018  0000000000000000 AXG       0     0     1</span><br><span class="line">  [10] .comment          PROGBITS         0000000000000000  00000090</span><br><span class="line">       000000000000002c  0000000000000001  MS       0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (<span class="built_in">link</span> order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  D (mbind), l (large), p (processor specific)</span><br></pre></td></tr></table></figure>

<p>他讲的就是 <code>lld</code> 后面说的字符串合并 (String Merge) or 字符串驻留, 需要构建一个哈希表来保存常量值, 以便查找常量项.</p>
<p><code>gold</code> 初始实现时候, 哈希查表的时间占据了 25% 的 CPU 时间. GNU 链接器通过在输入节中查找常量并在常量表中进行哈希表查找来实现此查找, 但是每次重定位引用常量时都需要重新计算哈希码. <code>Gold</code> 实现了一个输入偏移到输出偏移的映射, 这意味着链接器可以预先计算并缓存地址映射, 从而避免在重定位时重复计算哈希码</p>
<h4 id="3-2-5-性能"><a href="#3-2-5-性能" class="headerlink" title="3.2.5 性能"></a><em>3.2.5</em> 性能</h4><p>最终构建刚开始的 P 程序, 从 2 分多降低到 1 分 15s (50%), 更改一个源文件需要 13 s. 动态链接的时间降低到了原来的 63%, 静态链接耗时则降低到原来的 46% 的时间.</p>
<h4 id="3-2-6-ODR-One-Definition-Rule"><a href="#3-2-6-ODR-One-Definition-Rule" class="headerlink" title="3.2.6 ODR (One Definition Rule)"></a><em>3.2.6</em> ODR (One Definition Rule)</h4><p>C++ 中, <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/definition">ODR</a> 指的是两个或多个定义必须满足完全相同的需求, 尤其是 inline 函数可能有这种多个文件中定义的问题, 因此是很容易出错的. 但是实际中很难检测, C++ 并不要求编译器去报告. <code>GOLD</code> 可以使用 <code>--detect-odr-violation</code> 选项, 使用启发式算法查找违规, 比如两个文件中相同地符号, 并且符号有不同的大小才会报告. 但是这种存在误报.</p>
<h4 id="3-2-7-压缩-Debug-信息"><a href="#3-2-7-压缩-Debug-信息" class="headerlink" title="3.2.7 压缩 Debug 信息"></a><em>3.2.7</em> 压缩 Debug 信息</h4><p>Debug info 是高度可以压缩地, 可以使用 <code>--compress-debug-sections</code> 让 <code>Gold</code> 使用 <code>zlib</code> 来压缩.</p>
<h3 id="3-3-并行链接"><a href="#3-3-并行链接" class="headerlink" title="3.3 并行链接"></a><em>3.3</em> 并行链接</h3><p>这个主要参考 <a target="_blank" rel="noopener" href="https://smvv.io/gold.pdf">并行链接</a></p>
<h3 id="3-4-增量链接"><a href="#3-4-增量链接" class="headerlink" title="3.4 增量链接"></a><em>3.4</em> 增量链接</h3><p><a target="_blank" rel="noopener" href="https://gcc.gnu.org/wiki/GoldIncrementalLinking">增量链接</a></p>
<h2 id="4-llvm-的-lld"><a href="#4-llvm-的-lld" class="headerlink" title="4 llvm 的 lld"></a><em>4</em> <code>llvm</code> 的 <code>lld</code></h2><h3 id="4-1-性能提升"><a href="#4-1-性能提升" class="headerlink" title="4.1 性能提升"></a><em>4.1</em> 性能提升</h3>

<img src="/2024/linkers/ldd_sc.png" class="" title="ldd 的单核性能提升">

<p><code>ldd</code> 测量了不同时间的开销和占比:</p>
<img src="/2024/linkers/cost.png" class="" title="不同过程的占比">

<p>一大部分是拷贝和重定位, 设置好偏移量, 这个可以每个 section 自己拷贝自己的部分, 并且重定位自己的节的部分.</p>
<p>另一个很大的开销就是 String Merge (字符串唯一化). 常量字符串是单独存放在表中, 需要尽量缓存友好, 空间友好, 需要合并.</p>
<p><code>ldd</code> 就是通过 <code>hash</code> 进行字符串合并, 但是需要并行化, 于是他们就将 <code>hash</code> 分成了很多片, 类似云服务中的负载均衡的做法, 每个片负责一个 <code>hash</code>, 这个片内是单线程的, 所以不需要锁, 效率很高.</p>
<img src="/2024/linkers/hash.png" class="" title="hash table 进行 String Merge">

<p>优化之后的多线程这两个过程速度就很快了</p>
<img src="/2024/linkers/cost_after.png" class="" title="优化之后的时间占比">

<p>他们没有继续去做其他部分的并行, 因为其他部分占比非常小, 如果真的需要可以自己手动去定制, 据说比 <code>ld.bfd</code> 更好修改.</p>
<h3 id="4-2-一些其他的特性"><a href="#4-2-一些其他的特性" class="headerlink" title="4.2 一些其他的特性"></a><em>4.2</em> 一些其他的特性</h3><p>相比于 <code>gold</code>, 他们的代码行数更少, 除了依赖的库仅仅要 30k 行不到:</p>
<img src="/2024/linkers/loc.png" class="" title="ldd 的代码行数">

<p>并且可以输出更好的错误提示</p>
<img src="/2024/linkers/error.png" class="" title="ldd 的错误提示">

<p>此外还可以使用 <code>C&#123;,XX&#125;FLAGS=-flto and LDFLAGS=-fuse=lld</code> 来使用 <code>lld</code> 并且开启 LTO (Link Time Optimization)</p>
<p><code>lld</code> 还对于跨平台的链接支持更好, <code>gold</code> 只支持 <code>elf</code>, <code>ld</code> 则需要不同的版本, <code>lld</code> 天然支持跨平台, 甚至跨操作系统.</p>
<h3 id="4-3-Archive-符号解析的顺序"><a href="#4-3-Archive-符号解析的顺序" class="headerlink" title="4.3 Archive 符号解析的顺序"></a><em>4.3</em> Archive 符号解析的顺序</h3><p>并且, 在传统的链接器中, 顺序非常重要, 工作原理可以说是维护一个未定义的符号表, 会按照命令行的顺序加入或者删除 (解析) 符号. 当遇到一个 archive 的时候, 会尽可能多地解析 (删除) 集合中的未定义符号. 因此, <strong>一个静态链接库需要出现在使用这个该库的后面</strong>.</p>
<p>因此</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myadd</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">myadd</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myadd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的这些命令有的不可以</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># prepare archive</span></span><br><span class="line">g++ -c -o add.o add.cpp</span><br><span class="line">ar rcs libadd.a add.o</span><br><span class="line"><span class="comment"># 下面四个可以工作, 因为archive在用到这个库的后面</span></span><br><span class="line">g++ -o main -L. main.cpp -ladd</span><br><span class="line">g++ -o main main.cpp libadd.a</span><br><span class="line">g++ -o main add.o main.cpp</span><br><span class="line">g++ -o main main.cpp add.o</span><br><span class="line"><span class="comment"># 下面的这两个就无法工作, 提示找不到myadd</span></span><br><span class="line">g++ -o main  -L. -ladd main.cpp</span><br><span class="line">g++ -o main libadd.a main.cpp</span><br></pre></td></tr></table></figure>

<p>这个确实带来很多不便, 例如之前使用 <code>Cython</code> 的时候, 在某些环境, 其自动编译的脚本生成的命令 <strong>静态库</strong> 的顺序不太对, 就经常出现这种错误. 并且非常反直觉, 通常感觉都是我前面有声明&#x2F;定义, 后面才能用, 但是这个 <code>ld</code> 恰好相反.</p>
<p>但是 <code>lld</code> 就没有这个问题, 以上 case 全都工作.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g++ -o main -L. main.cpp -ladd -fuse-ld=lld</span><br><span class="line">g++ -o main main.cpp libadd.a -fuse-ld=lld</span><br><span class="line">g++ -o main  -L. -ladd main.cpp -fuse-ld=lld</span><br><span class="line">g++ -o main libadd.a main.cpp -fuse-ld=lld</span><br></pre></td></tr></table></figure>

<p>但是其实还是有点不理解 <code>ld</code> 为什么把 <code>a</code> 文件单独处理, 除了性能微弱的提升想不到有什么功能上的作用</p>
<p>看到:</p>
<blockquote>
<p>-( archives -)<br>–start-group archives –end-group<br>The archives should be a list of archive files. They may be either explicit file names, or -l options.<br>The specified archives are searched repeatedly until no new undefined references are created. Normally, an archive is searched only once in the order that it is specified on the command line. If a symbol in that archive is needed to resolve an undefined symbol referred to by an object in an archive that appears later on the command line, the linker would not be able to resolve that reference. By grouping the archives, they all be searched repeatedly until all possible references are resolved.<br>Using this option has a <strong>significant performance cost</strong>. It is best to use it only when there are unavoidable circular references between two or more archives.</p>
</blockquote>
<p>传统的 ld 可以使用类似 <code>ld  -o main -\( -ladd main.o -\) -e main -L.</code> 强制多次搜索静态链接库.</p>
<p>而强制多次搜索静态链接库则是为了解决两个静态库的循环依赖, 否则需要 <code>-la -lb -la</code> 的写法. 而默认不进行重复搜索就是单纯的性能考量. 如果仅仅是目标文件, 则其中的符号也需要出现在符号表中, 直接维护一个这样的符号表额外性能开销不大; 但是静态链接库的符号不需要暴露在符号表中, 并且比较独立, 相互依赖的情况较少, 维护这个表查询, 需要的开销.</p>
<h2 id="5-mold"><a href="#5-mold" class="headerlink" title="5 mold"></a><em>5</em> mold</h2><p>看到一个更强大的东西, <a target="_blank" rel="noopener" href="https://github.com/rui314/mold">mold</a>, 听起来就非常 modern, 用 <code>C++20</code> 写的, 据说比 <code>lld</code> 快几倍, 仅仅比 <code>cp</code> 慢两倍. 16c32t 下的速度:</p>
<img src="/2024/linkers/mold.png" class="" title="mold和lld以及gold的性能对比">

<p>原因除了使用更高效的数据结构和算法之外, 一个更直接的原因就是使用了更多的并行的组件:</p>
<img src="/2024/linkers/htop.gif" class="" title="lld(左)和mold(右)的处理器占用对比">

<p>对于如何使用更详细的选项可以参见 <a target="_blank" rel="noopener" href="https://github.com/rui314/mold/blob/main/docs/mold.md">使用手册</a>, 下面我们根据他的 <a target="_blank" rel="noopener" href="https://github.com/rui314/mold/blob/main/docs/design.md">设计手册</a> 来看一下他们的 design.</p>
<p><code>Mold</code> 和 <code>lld</code> 一样, 对于静态链接库的顺序没有任何的要求, 因为他们并不需要为了性能而这么折腾.</p>
<ul>
<li><code>mold</code> 会把过程分为前后两个部分, 前半部分就是符号解析和预处理, 后半部分主要是输出.</li>
<li>符号解析中 String interning 也是依靠哈希进行的, 也用类似的方法对常量字符串进行了合并.</li>
<li>对于动态链接库的 <code>GOT</code>, 他会创建一个单独的条目来处理, 并且进行并行化.</li>
</ul>
<h3 id="5-1-Linker-Script-支持"><a href="#5-1-Linker-Script-支持" class="headerlink" title="5.1 Linker Script 支持"></a><em>5.1</em> Linker Script 支持</h3><p>链接器脚本是一个文档非常稀缺的一个东西, 它主要用于控制输入部分如何映射到输出部分以及输出的布局, 对于嵌入式编程比较有用. 我也是才知道有这个东西, 比如拿来链接的 <code>libc.so</code> 其实就是一个 ASCII 文件:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ file /usr/lib/x86_64-linux-gnu/libc.so</span><br><span class="line">/usr/lib/x86_64-linux-gnu/libc.so: ASCII text</span><br><span class="line">$ <span class="built_in">head</span> -n 100 /usr/lib/x86_64-linux-gnu/libc.so</span><br><span class="line">/* GNU ld script</span><br><span class="line">   Use the shared library, but some <span class="built_in">functions</span> are only <span class="keyword">in</span></span><br><span class="line">   the static library, so try that secondarily.  */</span><br><span class="line">OUTPUT_FORMAT(elf64-x86-64)</span><br><span class="line">GROUP ( /lib/x86_64-linux-gnu/libc.so.6 /usr/lib/x86_64-linux-gnu/libc_nonshared.a  AS_NEEDED ( /lib64/ld-linux-x86-64.so.2 ) )</span><br></pre></td></tr></table></figure>

<p>链接器脚本允许执行许多棘手的操作, 例如指定文件的确切布局, 在 Section 之间插入任意字节等. 大部分都是二进制编辑工具比如 <code>objcopy</code> 可以做的.</p>
<p>但是有一些是 post-link editing tool 无法做的</p>
<ol>
<li>mapping input sections to output sections</li>
<li>applying relocations.</li>
</ol>
<p>因此 <code>mold</code> 仅仅实现了指定输入输出 section 的映射, 以及根据映射进行重定位, 其他的都可以使用编辑工具来弥补.</p>
<h3 id="5-2-Concurrency-strategy"><a href="#5-2-Concurrency-strategy" class="headerlink" title="5.2 Concurrency strategy"></a><em>5.2</em> Concurrency strategy</h3><p>在大多数地方, <code>mold</code> 采用数据并行. 例如一个循环中, 不同次数的循环之间没有数据和控制的依赖, 可以直接数据并行来分发给不同的执行单元.</p>
<p>但是上面是比较理想的状态, 在某一些时候, 循环时共享一些数据. 例如, 扫描重定位的循环打开符号表中符号的 <code>requires GOT</code> or <code>requires PLT</code>. Symbol 是一个共享资源, <code>mold</code> 将标志设置为 atomic variable.</p>
<p>此外 <code>Mold</code> 还会使用 map-reduce 的模式, 比如计算输出的 build id 时候, 使用 Merkle Tree 分两层计算哈希.</p>
<p><code>Mold</code> 中的几个地方使用了并发的 <code>hashmap</code></p>
<h3 id="5-3-Details"><a href="#5-3-Details" class="headerlink" title="5.3 Details"></a><em>5.3</em> Details</h3><h4 id="5-3-1-Quick-Exit"><a href="#5-3-1-Quick-Exit" class="headerlink" title="5.3.1 Quick Exit"></a><em>5.3.1</em> Quick Exit</h4><p>不同于 <code>lld</code> 使用 Amdahl’s law, <code>mold</code> 认为, 要实现极限的性能 (1s 链接 <code>Chromium</code>), 每一个部分都很重要. 如果映射了大量的文件, <code>_exit</code>退出的时间可能需要花费数百毫秒. 为此, 链接器组织成了两个进程, 第一个进程通过 <code>fork</code> 派生出第二个进程, 后者负责执行实际的链接任务, 在输出完目标文件之后, 第二个进程通知第一个进程去关闭, 然后第二个实际工作的进程自己去执行退出的系统调用和清理.</p>
<p>可以通过<code>--quick-exit</code>, <code>--no-quick-exit</code>来选择 Use or do not use quick_exit to exit.</p>
<h4 id="5-3-2-覆盖现有文件"><a href="#5-3-2-覆盖现有文件" class="headerlink" title="5.3.2 覆盖现有文件"></a><em>5.3.2</em> 覆盖现有文件</h4><p>至少在 <code>Linux</code> 上, 在创建新的大文件并使用 <code>mmap</code> 填充其内容时, 文件系统向新文件分配新块是性能瓶颈. 如果缓冲区缓存中已经有一个大文件, 则写入它比创建一个新文件并写入它要快得多.</p>
<p>根据这一观察, <code>mold</code> 会覆盖现有的可执行文件 (在增量编译时候). 基准测试表明, 创建 2 GiB 输出文件时可以节省 300 ms</p>
<p><code>Linux</code> 不允许打开正在运行的可执行文件进行写入 (作者说的, 可能是 <code>mmap</code> 不可以?). 如果无法打开输出文件, 则 <code>Mold</code> 会恢复到通常的方式.</p>
<h4 id="5-3-3-Build-Reproducibility"><a href="#5-3-3-Build-Reproducibility" class="headerlink" title="5.3.3 Build Reproducibility"></a><em>5.3.3</em> Build Reproducibility</h4><p>每次输出的二进制文件如果选项和输入相同, 则会产生相同的二进制. 便于调试.</p>
<h4 id="5-3-4-Build-Id-的构造"><a href="#5-3-4-Build-Id-的构造" class="headerlink" title="5.3.4 Build Id 的构造"></a><em>5.3.4</em> Build Id 的构造</h4><p><code>.build-id</code> 是嵌入到输出文件的唯一 ID, 通常是哈希文件的内容. 这是一个缓慢的步骤, <code>mold</code> 通过将文件分割成小块, 为每个块计算 <code>SHA-1</code>, 然后计算连接的 <code>SHA-1</code> 哈希值的 <code>SHA-1</code> (即构建高度为 2 的默克尔树 (Merkle Tree)) 来加快速度.</p>
<p>使用专用指令下, 哈希的计算速度为每个核心 2 GiB&#x2F;s, 16c 的处理器上, 2 GiB 文件的 build id 仅仅需要 60+ ms.</p>
<h4 id="5-3-5-Section-Garbage-Collection"><a href="#5-3-5-Section-Garbage-Collection" class="headerlink" title="5.3.5 Section Garbage Collection"></a><em>5.3.5</em> Section Garbage Collection</h4><p><code>ld.BFD</code>, <code>ld.gold</code>, <code>lld</code> 支持 Section 的垃圾回收. 即, 链接器运行标记-清除垃圾收集, 其中节是顶点, 重定位是边, 从 <code>_start</code> 开始, 标记每一个可以到达的边顶点, 也就是一个图上的遍历标记. 然后清除不需要的 Section.</p>
<p><code>Mold</code> 使用多线程来执行这个过程.</p>
<h4 id="5-3-6-COMDAT"><a href="#5-3-6-COMDAT" class="headerlink" title="5.3.6 COMDAT"></a><em>5.3.6</em> COMDAT</h4><h5 id="What-is-COMDAT-section"><a href="#What-is-COMDAT-section" class="headerlink" title="What is COMDAT section"></a>What is COMDAT section</h5><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/1834597/what-is-the-comdat-section-used-for">COMDAT section</a> 是一个可以合并的段. <code>COMDAT</code> 的目的是允许在多个目标文件中定义重复节. 如果在多个目标文件中定义了相同的符号, 链接器将报告错误. 例如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.cpp</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">add</span>(a, b); &#125;</span><br></pre></td></tr></table></figure>

<p>模板是在一个头文件中进行定义的, 然后可能多个文件都使用了这个模板, 都进行了实例化, 生成了目标文件.</p>
<p>如果按照一般的函数的处理方式, 多个使用了同一个模板, 同一个实例化的多个文件链接时候就会出现符号重定义的错误 (因此一般的函数定义都是在 <code>CPP</code> 文件中, 而不是 <code>HPP</code> 文件中进行的).</p>
<p>因此我们可以看一下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -c -o a.o a.cpp</span><br><span class="line">readelf  -a a.o</span><br></pre></td></tr></table></figure>

<p>可以得到下面信息</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  [ 6] .text._Z3add[...] PROGBITS         0000000000000000  0000006b</span><br><span class="line">       0000000000000018  0000000000000000 AXG       0     0     1</span><br><span class="line">...</span><br><span class="line">COMDAT group section [    1] `.group&#x27; [_Z3addIiET_S0_S0_] contains 1 sections:</span><br><span class="line">   [Index]    Name</span><br><span class="line">   [    6]   .text._Z3addIiET_S0_S0_</span><br><span class="line">...</span><br><span class="line">Symbol table &#x27;.symtab&#x27; contains 6 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS a.cpp</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    2 .text</span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 .text._Z3addIiET[...]</span><br><span class="line">     4: 0000000000000000    35 FUNC    GLOBAL DEFAULT    2 _Z3fooii</span><br><span class="line">     5: 0000000000000000    24 FUNC    WEAK   DEFAULT    6 _Z3addIiET_S0_S0_</span><br></pre></td></tr></table></figure>

<p>可以看到, 这个加法函数单独放到了一个 <code>.text</code> 段, 并且在<code> COMDAT group section</code> 中标记这个段可以合并. 并且… 在符号表中, 这个实例化出来的函数, 也被标记成了弱符号 (Weak Binding).</p>
<p><code>COMDAT</code> 合并有很多选项, 比如手动选择, 保证合并的段大小相同, 保证合并的段内容相同, 选择最大的等.</p>
<h5 id="Identical-Comdat-Folding"><a href="#Identical-Comdat-Folding" class="headerlink" title="Identical Comdat Folding"></a>Identical Comdat Folding</h5><p>链接器就是要干 <code>COMDAT</code> 段合并的任务, Identical Comdat Folding (ICF) 就是合并相同的 <code>COMDAT</code> 的段. ICF 合并两个或多个恰好具有相同内容和重定位的只读节. 链接器必须从较大的图中找到同构子图. 为此, <code>Mold</code> 实现了一种新算法, <code>Chromium</code> 来测量, <code>mold</code> 比 <code>lld</code> 执行 ICF 的速度快 5 倍 (5s-&gt;1s)</p>
<h4 id="5-3-7-Intel优化"><a href="#5-3-7-Intel优化" class="headerlink" title="5.3.7 Intel优化"></a><em>5.3.7</em> Intel优化</h4><p>使用 Intel 的 one TBB (oneAPI Threading Building Blocks) 的 <code>parallel_for_each</code> 和 <code>concurrent_hash_map</code></p>
<p>同时 TBB 提供了 <code>tbbmalloc</code>, 在多线程下, 比 glibc 的 malloc 更好, 但是 jemalloc 和 mimalloc 似乎比 tbbmalloc 拓展性更好.</p>
<h3 id="5-4-Rejected-ideas"><a href="#5-4-Rejected-ideas" class="headerlink" title="5.4 Rejected ideas"></a><em>5.4</em> Rejected ideas</h3><p>很有意思, 作者把这个也放上来了, 以免其他人提出来相同的 ISSUE</p>
<h4 id="5-4-1-可变长度放到文件末尾-再完全确定文件布局之前进行拷贝"><a href="#5-4-1-可变长度放到文件末尾-再完全确定文件布局之前进行拷贝" class="headerlink" title="5.4.1 可变长度放到文件末尾, 再完全确定文件布局之前进行拷贝"></a><em>5.4.1</em> 可变长度放到文件末尾, 再完全确定文件布局之前进行拷贝</h4><p>链接器必须消除重复的 <code>comdat</code> 部分, 因此在解析所有符号并消除重复的 <code>comdat</code> 之前, 无法计算常规部分的布局, 这需要几百毫秒. 可变长度部分的大小计算时间仅仅需要不到 100 ms. 这个提升非常小 (&lt;100ms?).</p>
<p>另一个更重要的原因是因为这个想法很有可能对链接器的整体性能产生负面影响. 如果我们在确定布局之前复制文件内容, 则在复制时无法对它们应用重定位, 因为符号地址尚不可用. 如果我们首先确定文件布局, 我们可以在复制时应用重定位, 可以获得很好的数据局部性.</p>
<h4 id="5-4-2-Incremental-linking"><a href="#5-4-2-Incremental-linking" class="headerlink" title="5.4.2 Incremental linking"></a><em>5.4.2</em> Incremental linking</h4><p>这个其实是我很感兴趣的.</p>
<p>这里说 <code>GNU BFD and gold linkers support it.</code>, 但是 <code>mold</code> 不支持.</p>
<p>主要的原因有两个, 一个是太复杂, 正确性难以保证; 第二就是未必会带来性能提升.</p>
<p>首先就是这个增量链接会非常复杂. 首先要定位和比对修改文件中的变化, 这个就很复杂了, 之后面对不同的修改更繁琐. 比如更新的文件删除了一个符号, 需要重新搜索有没有这样的符号, 并且容易产生连锁反应; 类似的弱符号和 <code>COMDAT</code> 块也存在类似的问题. 并且修改的时候可能要修改每个用到的地址. 整个链接过程是牵一发动全身的. 因此尽管 <code>GOLD</code> 实现了增量链接, 为了正确性, 也很容易地退回到从头链接.</p>
<p>其次就是这个未必会带来性能提升, 比如对于文件修改的校对; 对于地址变化的符号还需要检查文件中的对应的位置进行修改; 如果内容有增加, 一般需要增加 Padding, 以免影响后面的 Section, 但是超出了 Padding, 后面的 Section 中函数入口地址也会发生变化.</p>
<h4 id="5-4-3-其他"><a href="#5-4-3-其他" class="headerlink" title="5.4.3 其他"></a><em>5.4.3</em> 其他</h4><p>自己创建可执行文件的格式来加快链接过程. 兼容性不好保证, 而且 <code>ELF</code> 也没有那么差, 未必能带来性能提升.</p>
<p><code>inotify</code> 来监控文件更新更新后立马重新构建, 作者还在反驳, 说能监控的文件数量不多什么的. 但是如果每次保存都要重新构建, 而且大部分时候应该是失败的, 经常保存的人会造成机器卡顿.</p>
<h3 id="5-5-Size-of-the-problem"><a href="#5-5-Size-of-the-problem" class="headerlink" title="5.5 Size of the problem"></a><em>5.5</em> Size of the problem</h3><p>较为大型的项目, 链接的过程可能非常大:</p>
<table>
<thead>
<tr>
<th>Data item</th>
<th>Number</th>
</tr>
</thead>
<tbody><tr>
<td>Object files</td>
<td>30,723</td>
</tr>
<tr>
<td>Public undefined symbols</td>
<td>1,428,149</td>
</tr>
<tr>
<td>Mergeable strings</td>
<td>1,579,996</td>
</tr>
<tr>
<td>Comdat groups</td>
<td>9,914,510</td>
</tr>
<tr>
<td>Regular sections¹</td>
<td>10,345,314</td>
</tr>
<tr>
<td>Public defined symbols</td>
<td>10,512,135</td>
</tr>
<tr>
<td>Symbols</td>
<td>23,953,607</td>
</tr>
<tr>
<td>Sections</td>
<td>27,543,225</td>
</tr>
<tr>
<td>Relocations against SHF_ALLOC sections</td>
<td>39,496,375</td>
</tr>
<tr>
<td>Relocations</td>
<td>62,024,719</td>
</tr>
</tbody></table>
<p>这么多的 Symbols, 现在有点理解 <code>ld</code> 对于 <code>archive</code> 库的处理了…</p>
<h3 id="5-6-其他"><a href="#5-6-其他" class="headerlink" title="5.6 其他"></a><em>5.6</em> 其他</h3><p><code>mold</code> 的作者还很详细地在 design 中介绍了链接器地发展历史和困难, <code>archive</code> 文件的历史</p>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7 总结"></a><em>7</em> 总结</h2><p>简单调研了 <code>ld.bfd</code>, <code>ld.gold</code>, <code>lld</code> 和 <code>mold</code> 这几个链接器, 以及他们实现的功能和大概的性能. 尤其是后面三个如何进行的并行化操作.</p>
<p>一开始我以为并行链接是一个很难的事情, 后来发现除了最开始的默认的 <code>bfd</code>, 其余的都可以并行链接. 事实证明, 只要有问题一定有人尝试解决, 只要理论上可实现, 并且实现成本不是特别巨大, 肯定有人尝试过.</p>
<p>后续对比一下这四个编译器的速度和质量(文件大小, 性能等), 使用一些小型的项目, 比如gRPC和redis等.</p>

    </div>

    
    
    

      <div> <div class="my-post-copyright">
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

  <!-- JS库 sweetalert 可修改路径 -->
  <script type="text/javascript" src="http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js"></script>
  <script src="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js"></script>
  <link rel="stylesheet" type="text/css" href="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css">

  <p><span>本文标题:</span>并行 / 增量链接 -- ld.bfd, ld.gold, lld, mold 的设计</a></p>
  <p><span>文章作者:</span></a></p>
  <p><span>发布时间:</span>2024年05月06日 - 16:33:08</p>
  <p><span>最后更新:</span>2025年08月05日 - 01:49:59</p>
  <p><span>原始链接:</span><a href="/2024/linkers/" title="并行 / 增量链接 -- ld.bfd, ld.gold, lld, mold 的设计">https://zombie12138.github.io/2024/linkers/</a>
    <span class="copy-path"  title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="https://zombie12138.github.io/2024/linkers/"  aria-label="复制成功！"></i></span>
  </p>
  <p><span>特殊声明:</span>本篇文章由我个人在空闲时间独立制作。所有观点、看法及内容均为个人意见，不代表任何组织或公司的立场。</p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p>
</div>
<script>
    var clipboard = new Clipboard('.fa-clipboard');
    clipboard.on('success', $(function(){
      $(".fa-clipboard").click(function(){
        swal({
          title: "",
          text: '复制成功',
          html: false,
          timer: 500,
          showConfirmButton: false
        });
      });
    }));
</script>
 </div>

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Compiler/" rel="tag"># Compiler</a>
              <a href="/tags/Survey/" rel="tag"># Survey</a>
              <a href="/tags/Linker/" rel="tag"># Linker</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/aphorisms/" rel="prev" title="计算机相关的英文的专有名词, 缩写和名言警句">
      <i class="fa fa-chevron-left"></i> 计算机相关的英文的专有名词, 缩写和名言警句
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/ESPAsyncWebSrv/" rel="next" title="ESPAsyncWebSrv 库源码">
      ESPAsyncWebSrv 库源码 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E9%97%AE%E9%A2%98"><span class="nav-number">1.</span> <span class="nav-text">1 问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%93%BE%E6%8E%A5%E8%BF%99%E4%B9%88%E6%85%A2"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 为什么链接这么慢</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E6%80%8E%E4%B9%88%E5%8A%A0%E5%BF%AB%E9%93%BE%E6%8E%A5%E9%80%9F%E5%BA%A6"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 怎么加快链接速度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-%E5%A2%9E%E9%87%8F%E9%93%BE%E6%8E%A5"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.2.1 增量链接</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#MSVC-link-exe"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">MSVC link.exe</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ld"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">ld</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#gold-lld"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">gold &amp;&amp; lld</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-%E5%B9%B6%E8%A1%8C%E9%93%BE%E6%8E%A5"><span class="nav-number">1.2.2.</span> <span class="nav-text">1.2.2 并行链接</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-LD-BFD"><span class="nav-number">2.</span> <span class="nav-text">2 LD.BFD</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-GOLD"><span class="nav-number">3.</span> <span class="nav-text">3 GOLD</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E8%83%8C%E6%99%AF"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 背景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E8%AE%BE%E8%AE%A1"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-%E7%89%B9%E6%80%A7"><span class="nav-number">3.2.1.</span> <span class="nav-text">3.2.1 特性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E4%BC%98%E5%8C%96"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">流程优化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9C%81%E7%95%A5%E9%BB%98%E8%AE%A4%E9%93%BE%E6%8E%A5%E5%99%A8%E8%84%9A%E6%9C%AC%E4%B8%8E%E5%8A%A8%E6%80%81%E5%B8%83%E5%B1%80"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">省略默认链接器脚本与动态布局</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.2.2.</span> <span class="nav-text">3.2.2 多线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-%E9%87%87%E7%94%A8-C-%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%8C%96%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96"><span class="nav-number">3.2.3.</span> <span class="nav-text">3.2.3 采用 C++ 模板特化进行优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-4-Merge-Sections"><span class="nav-number">3.2.4.</span> <span class="nav-text">3.2.4 Merge Sections</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-5-%E6%80%A7%E8%83%BD"><span class="nav-number">3.2.5.</span> <span class="nav-text">3.2.5 性能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-6-ODR-One-Definition-Rule"><span class="nav-number">3.2.6.</span> <span class="nav-text">3.2.6 ODR (One Definition Rule)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-7-%E5%8E%8B%E7%BC%A9-Debug-%E4%BF%A1%E6%81%AF"><span class="nav-number">3.2.7.</span> <span class="nav-text">3.2.7 压缩 Debug 信息</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E5%B9%B6%E8%A1%8C%E9%93%BE%E6%8E%A5"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 并行链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E5%A2%9E%E9%87%8F%E9%93%BE%E6%8E%A5"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 增量链接</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-llvm-%E7%9A%84-lld"><span class="nav-number">4.</span> <span class="nav-text">4 llvm 的 lld</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 性能提升</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E4%B8%80%E4%BA%9B%E5%85%B6%E4%BB%96%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 一些其他的特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-Archive-%E7%AC%A6%E5%8F%B7%E8%A7%A3%E6%9E%90%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="nav-number">4.3.</span> <span class="nav-text">4.3 Archive 符号解析的顺序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-mold"><span class="nav-number">5.</span> <span class="nav-text">5 mold</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-Linker-Script-%E6%94%AF%E6%8C%81"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 Linker Script 支持</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-Concurrency-strategy"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 Concurrency strategy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-Details"><span class="nav-number">5.3.</span> <span class="nav-text">5.3 Details</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-1-Quick-Exit"><span class="nav-number">5.3.1.</span> <span class="nav-text">5.3.1 Quick Exit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-2-%E8%A6%86%E7%9B%96%E7%8E%B0%E6%9C%89%E6%96%87%E4%BB%B6"><span class="nav-number">5.3.2.</span> <span class="nav-text">5.3.2 覆盖现有文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-3-Build-Reproducibility"><span class="nav-number">5.3.3.</span> <span class="nav-text">5.3.3 Build Reproducibility</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-4-Build-Id-%E7%9A%84%E6%9E%84%E9%80%A0"><span class="nav-number">5.3.4.</span> <span class="nav-text">5.3.4 Build Id 的构造</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-5-Section-Garbage-Collection"><span class="nav-number">5.3.5.</span> <span class="nav-text">5.3.5 Section Garbage Collection</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-6-COMDAT"><span class="nav-number">5.3.6.</span> <span class="nav-text">5.3.6 COMDAT</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#What-is-COMDAT-section"><span class="nav-number">5.3.6.1.</span> <span class="nav-text">What is COMDAT section</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Identical-Comdat-Folding"><span class="nav-number">5.3.6.2.</span> <span class="nav-text">Identical Comdat Folding</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-7-Intel%E4%BC%98%E5%8C%96"><span class="nav-number">5.3.7.</span> <span class="nav-text">5.3.7 Intel优化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-Rejected-ideas"><span class="nav-number">5.4.</span> <span class="nav-text">5.4 Rejected ideas</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-1-%E5%8F%AF%E5%8F%98%E9%95%BF%E5%BA%A6%E6%94%BE%E5%88%B0%E6%96%87%E4%BB%B6%E6%9C%AB%E5%B0%BE-%E5%86%8D%E5%AE%8C%E5%85%A8%E7%A1%AE%E5%AE%9A%E6%96%87%E4%BB%B6%E5%B8%83%E5%B1%80%E4%B9%8B%E5%89%8D%E8%BF%9B%E8%A1%8C%E6%8B%B7%E8%B4%9D"><span class="nav-number">5.4.1.</span> <span class="nav-text">5.4.1 可变长度放到文件末尾, 再完全确定文件布局之前进行拷贝</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-2-Incremental-linking"><span class="nav-number">5.4.2.</span> <span class="nav-text">5.4.2 Incremental linking</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-3-%E5%85%B6%E4%BB%96"><span class="nav-number">5.4.3.</span> <span class="nav-text">5.4.3 其他</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-Size-of-the-problem"><span class="nav-number">5.5.</span> <span class="nav-text">5.5 Size of the problem</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-6-%E5%85%B6%E4%BB%96"><span class="nav-number">5.6.</span> <span class="nav-text">5.6 其他</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E6%80%BB%E7%BB%93"><span class="nav-number">6.</span> <span class="nav-text">7 总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zombie12138</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">56</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zombie12138</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
