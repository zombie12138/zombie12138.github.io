<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zombie12138.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="链接非常慢, 不太好利用多核性能, 修改任何一个文件, 往往都需要修改最后的链接过程(动态库或最终的可执行文件).  今天来简单比较一下不同链接器的性能, 在Redis做链接结果的性能对比.">
<meta property="og:type" content="article">
<meta property="og:title" content="常见链接器 -- ld.bfd, ld.gold, lld, mold的设计">
<meta property="og:url" content="https://zombie12138.github.io/2024/linkers/index.html">
<meta property="og:site_name" content="zombie&#39;s">
<meta property="og:description" content="链接非常慢, 不太好利用多核性能, 修改任何一个文件, 往往都需要修改最后的链接过程(动态库或最终的可执行文件).  今天来简单比较一下不同链接器的性能, 在Redis做链接结果的性能对比.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zombie12138.github.io/2024/linkers/ldd_sc.png">
<meta property="og:image" content="https://zombie12138.github.io/2024/linkers/cost.png">
<meta property="og:image" content="https://zombie12138.github.io/2024/linkers/hash.png">
<meta property="og:image" content="https://zombie12138.github.io/2024/linkers/cost_after.png">
<meta property="og:image" content="https://zombie12138.github.io/2024/linkers/loc.png">
<meta property="og:image" content="https://zombie12138.github.io/2024/linkers/error.png">
<meta property="og:image" content="https://zombie12138.github.io/2024/linkers/mold.png">
<meta property="og:image" content="https://zombie12138.github.io/2024/linkers/htop.gif">
<meta property="article:published_time" content="2024-05-06T08:33:08.000Z">
<meta property="article:modified_time" content="2024-05-06T08:39:43.872Z">
<meta property="article:author" content="zombie12138">
<meta property="article:tag" content="Survey">
<meta property="article:tag" content="Compiler">
<meta property="article:tag" content="Linker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zombie12138.github.io/2024/linkers/ldd_sc.png">

<link rel="canonical" href="https://zombie12138.github.io/2024/linkers/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>常见链接器 -- ld.bfd, ld.gold, lld, mold的设计 | zombie's</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">zombie's</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zombie12138.github.io/2024/linkers/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zombie12138">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zombie's">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          常见链接器 -- ld.bfd, ld.gold, lld, mold的设计
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-05-06 16:33:08 / 修改时间：16:39:43" itemprop="dateCreated datePublished" datetime="2024-05-06T16:33:08+08:00">2024-05-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>链接非常慢, 不太好利用多核性能, 修改任何一个文件, 往往都需要修改最后的链接过程(动态库或最终的可执行文件). </p>
<p>今天来简单比较一下不同链接器的性能, 在Redis做链接结果的性能对比.</p>
<span id="more"></span>

<p>我们主要参考了每一个链接器一篇文章, 对比了ld.bfd, ld.gold, llvm ld和mold.</p>
<p>每一个链接器一篇文章. ld.bfd的太详细, 并且由于其基于bfd, 所以有很多遗留的问题和概念, 但是我认为这些概念并不是通用的, 因此没有仔细看</p>
<ul>
<li>ld.bfd: <a target="_blank" rel="noopener" href="https://www.eecs.umich.edu/courses/eecs373/readings/Linker.pdf">The GNU Linker</a></li>
<li>ld.gold: <a target="_blank" rel="noopener" href="https://research.google.com/pubs/archive/34417.pdf">A New ELF Linker</a>, <a target="_blank" rel="noopener" href="https://smvv.io/gold.pdf">并行链接</a>, <a target="_blank" rel="noopener" href="https://gcc.gnu.org/wiki/GoldIncrementalLinking">增量链接</a></li>
<li>lld: <a target="_blank" rel="noopener" href="https://llvm.org/devmtg/2017-10/slides/Ueyama-lld.pdf">Slides</a></li>
<li>mold: <a target="_blank" rel="noopener" href="https://github.com/rui314/mold">Design.md</a></li>
</ul>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="为什么总是这么慢"><a href="#为什么总是这么慢" class="headerlink" title="为什么总是这么慢"></a>为什么总是这么慢</h3><p>编译的时间非常慢, 尤其是进度条到最后99的时候总是会非常卡, 卡到不行, 这是在进行链接. 有时候我们仅仅改了一个文件, 但是依然需要链接大半天.</p>
<p>其实问题也很简单, 因为编译的过程可以看作一个DAG(有向无环图), 在不同的文件之间, 其编译的过程是相对独立的, 因此不同任务之间是可以并行的. 但是链接过程往往在DAG的最后, 并且同时接收多个输入, 因此最后进行单线程处理多个文件, 进行符号解析, 重定位等操作.</p>
<p>每次修改一个文件, 沿着DAG的边上的都需要重新编译, 这个时候最终的往往是一个链接的过程, 并且链接依然是又大量的不同文件作为输入, 难以并行.</p>
<h3 id="怎么解决"><a href="#怎么解决" class="headerlink" title="怎么解决"></a>怎么解决</h3><p>对于编译我们可以并行, 分布式, 增量, 预编译头文件, 分割代码库等.<br>上面的操作可能就分割代码库对于链接速度的帮助较大, 而增量链接和并行化较难实现.</p>
<p>链接依然生成的单个文件, 并且一个前面的代码段修改之后, 里面的的地址也需要改变, 因此依赖其的调用也需要都要改变; 如果代码体积变化, 可能引起后面段的位置也要改变, 因此实现一个增量的链接比较困难, 及时实现也很容易退回到全量链接. 但是发现msvc似乎可以实现<strong>增量链接</strong>(<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Dahaka/archive/2011/08/01/2124256.html">似乎不可避免地带来了空间地膨大</a>), 并且总结也会提到ld和gold实现的增量编译.</p>
<p>对于链接的并行也是类似, 因为是单个文件, 因此存在一些依赖关系, 虽然可以实现, 但是比起多个文件并行地编译这种几乎免费地午餐还是比较复杂一点. 但是由于真的是太慢了, 所以除了ld.bfd其他的都实现了这个.</p>
<p>Linux下的连接器很多, 比如ld.bfd, ld.<a target="_blank" rel="noopener" href="https://research.google.com/pubs/archive/34417.pdf">GOLD</a>, llvm的<a target="_blank" rel="noopener" href="https://llvm.org/devmtg/2017-10/slides/Ueyama-lld.pdf">lld</a>, 以及<a target="_blank" rel="noopener" href="https://github.com/rui314/mold">mold</a>. 这几个的性能是逐渐提升的. 我们分别参考了其中设计的文章或者Slides, 来分别讨论这几个链接器的设计.</p>
<h2 id="GOLD"><a href="#GOLD" class="headerlink" title="GOLD"></a>GOLD</h2><p>GOLD的设计在<a target="_blank" rel="noopener" href="https://research.google.com/pubs/archive/34417.pdf"><A New ELF Linker></a>中奖了很多, 相对于LD主要是舍弃了BFD, 并且添加了多线程的支持(很少), 以及使用C++.</p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>这个似乎是Google的人搞出来的, 并且这个人还参与了之前的普通的ld(bfd)的贡献? 同样他们举了个例子, GOOGLE的内部程序, 链接输出超过700M, 1300个输入对象, 400000个全局符号, 编译需要11分钟, 其中链接就需要2分多钟, 并且是串行的.</p>
<p>之前的ld.bfd链接分为以下几个部分:</p>
<ul>
<li>浏览所有输入文件, 识别符号和输入部分</li>
<li>遍历linker script链接器标本, 根据每个输入Section的名称将其分配给输出Section</li>
<li>再次浏览链接描述文件，为输出节分配地址</li>
<li>再次遍历输入文件，将输入部分复制到输出文件并应用重定位</li>
</ul>
<p>linker script是用来控制输出不同section的空间布局等信息的, 比如<code>/usr/lib/x86_64-linux-gnu/libc.so</code>其实是一个Linker Script. GNU的linker有默认的script, 使用<code>g++ -Wl,--verbose main.cpp</code>就可以看到.</p>
<p>典型的ELF linker要遍历很多很多次符号表, 包括依次执行下面的这些任务(有的也有点不太清楚具体是什么意思):</p>
<ul>
<li>给符号分配版本号(?)</li>
<li>设置动态对象的符号的值</li>
<li>构建GOT和PLT表</li>
<li>查看是否存在应用于只读section的重定位(?)</li>
<li>查找符号版本依赖(?)</li>
<li>计算动态符号的哈希</li>
<li>…</li>
</ul>
<p>这些遍历过程有的很容易去合并, 但是GOLD仅仅遍历符号表三次.</p>
<p>这一段中分层也不太懂什么意思: GNU的链接器是构建在BFD(Binary File Descriptor)库上, 是通过BFD链接器符号表上分层实现的, 大多数的ELF后端都会在基本ELF上添加附加信息. 这些信息会重复并且妨碍对齐优化. 符号表中(应该是编译中的), gold相比BFD, 32bit的条目80B-&gt;48B, 64bit下, 156B-&gt;68B. 分层也会使得GNU链接器必须对ELF文件中的符号设置版本(?).</p>
<p>gnu传统的ld.bfd也是C语言写的(唉, C语言), 链表-&gt;哈希表这些数据结构的改变或者自动调整哈希表大小都很困难, 处理大型代码的时候速度很容易非常慢. BFD也提供了自动调整大小的哈希表, 但是key必须是字符串.</p>
<p>这个作者似乎为ld.bfd做出了很多贡献, 但是他认为应该重写, 并且抛弃BFD.</p>
<h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>Gold就是一个仅仅针对ELF的一个链接器, 使用C++编写, 使用模板特化来避免由于字节交换而导致的速度减慢(?). GOLD的流程如下:</p>
<ul>
<li>浏览输入文件, 识别符号和输入部分</li>
<li>再次浏览输入文件, 读取重定位并构建PLT和GOT</li>
<li>将输出节分配给输出段, 并将地址分配给输出段</li>
<li>再次遍历输入文件，将输入部分复制到输出文件并应用重定位</li>
</ul>
<p>与GNU链接器ld.bfd的主要区别在于第二次遍历输入文件以读取重定位, 以及省略了链接器脚本(ld.bfd有一个默认的linker script). 使用第二次遍历输入文件来读取重定位可以简化符号处理, 它还避免了遍历符号表. 由于没有默认的链接描述文件, 因此可以在读取输入节时将其分配给输出节. 输出节可以根据其类型和标志(rwx)分组为输出段, 而不是根据链接描述文件中设置的地址</p>
<h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>Gold是多线程的, 但是这个多线程的部分非常有限, 目的是允许链接器重叠磁盘任务和CPU任务. 链接过程被分成任务, 组织成一个DAG, 细粒度的锁很少, 工作线程池会在任务可用时获取任务. 作者认为: <strong>实践中并没有证明使用多线程可以显着提高性能, 在某些情况下这是一个微小的改进, 在另一些情况下则是轻微的放缓</strong>, 以至于作者认为可能是实现错误. 但是后面被lld和mold打脸了, gold后面应该性能也会改善, 但是还是不是很快.</p>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><p>Gold使用模板特化来实现byte swap, 任何从输入文件读取链接信息的函数, 例如section headers等, 都是为基于输出的ELF文件的类的模板. 在不同的机器(大小端)上执行不同的代码.</p>
<p>用了22中不同的翰洗标, 有多种不同的Key的类型, 并且添加哈希表很容易. </p>
<h4 id="Merge-Sections"><a href="#Merge-Sections" class="headerlink" title="Merge Sections"></a>Merge Sections</h4><p>这个合并部分, 即ELF中设置了<code>SHF_MERGE</code>的section是可以合并的, 是耗时最长的操作之一. 文中说这个是包含一些常量, 比如字符串常量, 但是这个似乎和COMDAT的还不一样, 不太清楚这个什么时候出现, 我能找到的就是注释段.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">readelf -WS a.o</span><br><span class="line">File: a.o</span><br><span class="line">There are 18 section headers, starting at offset 0x328:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al</span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 6] .rodata           PROGBITS         0000000000000000  0000006b</span><br><span class="line">       0000000000000005  0000000000000000   A       0     0     1</span><br><span class="line">  [ 9] .text._Z3add[...] PROGBITS         0000000000000000  00000078</span><br><span class="line">       0000000000000018  0000000000000000 AXG       0     0     1</span><br><span class="line">  [10] .comment          PROGBITS         0000000000000000  00000090</span><br><span class="line">       000000000000002c  0000000000000001  MS       0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (<span class="built_in">link</span> order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  D (mbind), l (large), p (processor specific)</span><br></pre></td></tr></table></figure>

<p>他讲的可能就是lld后面说的字符串合并or字符串驻留, 需要构建一个哈希表来保存常量值, 以便查找常量项.</p>
<p>gold初始实现时候, 哈希查表的时间占据了25%的CPU时间. GNU链接器通过在输入节中查找常量并在常量表中进行哈希表查找来实现此查找, 但是每次重定位引用常量时都需要重新计算哈希码. Gold实现了一个输入偏移到输出偏移的映射(我的理解是, 之前重定位的时候, 每次都要计算, 现在是利用之前合并前的地址, 直接查表就可以获得合并之后的地址).</p>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>最终构建刚开始的P程序, 从2分多降低到1分15s(50%), 更改一个源文件需要13s. 动态链接的时间降低到了原来的63%, 静态则大约提升到46%的时间.</p>
<h3 id="Feature"><a href="#Feature" class="headerlink" title="Feature"></a>Feature</h3><h4 id="ODR-One-Definition-Rule"><a href="#ODR-One-Definition-Rule" class="headerlink" title="ODR(One Definition Rule)"></a>ODR(One Definition Rule)</h4><p>C++中, <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/definition">ODR</a>指的是两个或多个定义必须满足完全相同的需求, 尤其是inline函数可能有这种多个文件中定义地问题, 因此是很容易出错的. 但是实际中很难检测, C++并不要求编译器去报告. GOLD可以使用<code> --detect-odr-violation</code>选项, 使用启发式算法查找违规, 比如两个文件中相同地符号, 并且符号有不同的大小才会报告. 但是这种存在误报(为什么呢).</p>
<h4 id="压缩Debug信息"><a href="#压缩Debug信息" class="headerlink" title="压缩Debug信息"></a>压缩Debug信息</h4><p>Debug info是高度可以压缩地, 可以使用<code>--compress-debug-sections</code>让Gold使用zlib来压缩.</p>
<h4 id="已经实现了的未来"><a href="#已经实现了的未来" class="headerlink" title="已经实现了的未来"></a>已经实现了的未来</h4><p><a target="_blank" rel="noopener" href="https://smvv.io/gold.pdf">并行链接</a>, <a target="_blank" rel="noopener" href="https://gcc.gnu.org/wiki/GoldIncrementalLinking">增量链接</a>, 但是这两个应该都实现了</p>
<h2 id="llvm的lld"><a href="#llvm的lld" class="headerlink" title="llvm的lld"></a>llvm的lld</h2><h3 id="性能提升"><a href="#性能提升" class="headerlink" title="性能提升"></a>性能提升</h3>

<img src="/2024/linkers/ldd_sc.png" class="" title="ldd的单核性能提升">

<p>ldd测量了不同时间的开销和占比:</p>
<img src="/2024/linkers/cost.png" class="" title="不同过程的占比">

<p>一大部分是拷贝和重定位, 设置好偏移量, 这个可以每个section自己拷贝自己的部分, 并且重定位自己的节的部分.</p>
<p>另一个很大的开销就是String Merge(字符串唯一化?). 常量字符串是单独存放在表中, 需要尽量缓存友好, 空间友好, 需要合并. (我理解是, 除了常量字符串的合并, 里面的一些符号解析过程中, 也需要一个类似的过程, 他这个String Merge应该是两个都包含)</p>
<p>ldd就是通过hash进行字符串合并, 但是需要并行化, 于是他们就将hash分成了很多片, 类似云服务中的负载均衡的做法, 每个片负责一个hash, 这个片内是单线程的, 所以不需要锁, 效率很高. 但是具体是怎么做的我其实不太清楚, 是每个分区扫一遍各自的字符串表, 仅仅关注自己的任务, 还是类似一个生产者消费者去塞到队列里面.</p>
<img src="/2024/linkers/hash.png" class="" title="hash table进行String Merge">

<p>优化之后的多线程这两个过程速度就很快了</p>
<img src="/2024/linkers/cost_after.png" class="" title="优化之后的时间占比">

<p>他们没有继续去做其他部分的并行, 因为其他部分占比非常小, 如果真的需要可以自己手动去定制, 据说比ld.bfd更好修改.</p>
<h3 id="一些其他的特性"><a href="#一些其他的特性" class="headerlink" title="一些其他的特性"></a>一些其他的特性</h3><p>相比于gold, 他们的代码行数更少, 除了依赖的库仅仅要30k行不到:</p>
<img src="/2024/linkers/loc.png" class="" title="ldd的代码行数">

<p>并且可以输出更好的错误提示</p>
<img src="/2024/linkers/error.png" class="" title="ldd的错误提示">

<p>此外还可以使用<code>C&#123;,XX&#125;FLAGS=-flto and LDFLAGS=-fuse=lld</code>来使用lld并且开启LTO(Link time optimization)</p>
<p>lld还对于跨平台的链接支持更好, gold只支持elf, ld则需要不同的版本, lld天然支持跨平台, 甚至跨操作系统.</p>
<h3 id="Archive符号解析的顺序"><a href="#Archive符号解析的顺序" class="headerlink" title="Archive符号解析的顺序"></a>Archive符号解析的顺序</h3><p>并且, 在传统的链接器中, 顺序非常重要, 工作原理可以说是维护一个未定义的符号表, 会按照命令行的顺序加入或者删除(解析)符号. 当遇到一个archive(静态链接库)的时候, 会尽可能多地解析(删除)集合中的未定义符号. 因此, 一个静态链接库需要出现在使用这个该库的后面. </p>
<p>因此</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myadd</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">myadd</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myadd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的这些命令有的不可以</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># prepare archive</span></span><br><span class="line">g++ -c -o add.o add.cpp</span><br><span class="line">ar rcs libadd.a add.o</span><br><span class="line"><span class="comment"># 下面四个可以工作, 因为archive在用到这个库的后面</span></span><br><span class="line">g++ -o main -L. main.cpp -ladd</span><br><span class="line">g++ -o main main.cpp libadd.a</span><br><span class="line">g++ -o main add.o main.cpp</span><br><span class="line">g++ -o main main.cpp add.o</span><br><span class="line"><span class="comment"># 下面的这两个就无法工作, 提示找不到myadd</span></span><br><span class="line">g++ -o main  -L. -ladd main.cpp</span><br><span class="line">g++ -o main libadd.a main.cpp</span><br></pre></td></tr></table></figure>

<p>这个确实蛮恶心的, 尤其是之前使用Cpython的时候, 在某些环境, 其自动编译的脚本生成的命令静态库的顺序不太对, 就经常出先这种错误. </p>
<p>并且非常反直觉, 通常感觉都是我前面有声明&#x2F;定义, 后面才能用, 但是这个ld恰好相反.</p>
<p>但是lld就没有这个问题, 全都工作, 其实感觉也没有多神奇, 主要是之前的太反人类了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g++ -o main -L. main.cpp -ladd -fuse-ld=lld</span><br><span class="line">g++ -o main main.cpp libadd.a -fuse-ld=lld</span><br><span class="line">g++ -o main  -L. -ladd main.cpp -fuse-ld=lld</span><br><span class="line">g++ -o main libadd.a main.cpp -fuse-ld=lld</span><br></pre></td></tr></table></figure>

<p>但是其实还是有点不理解ld为什么把a文件单独处理, 除了性能微弱的提升想不到有什么功能上的作用</p>
<p>看到:</p>
<blockquote>
<p>-( archives -)<br>–start-group archives –end-group<br>The archives should be a list of archive files. They may be either explicit file names, or -l options.<br>The specified archives are searched repeatedly until no new undefined references are created. Normally, an archive is searched only once in the order that it is specified on the command line. If a symbol in that archive is needed to resolve an undefined symbol referred to by an object in an archive that appears later on the command line, the linker would not be able to resolve that reference. By grouping the archives, they all be searched repeatedly until all possible references are resolved.<br>Using this option has a <strong>significant performance cost</strong>. It is best to use it only when there are unavoidable circular references between two or more archives.</p>
</blockquote>
<p>传统的ld可以使用类似<code> ld  -o main -\( -ladd main.o -\) -e main -L.</code>强制多次搜索静态链接库.</p>
<p>而强制多次搜索静态链接库则是为了解决两个静态库的循环依赖, 否则需要<code>-la -lb -la</code>的写法. 而默认不进行重复搜索就是单纯的性能考量. 如果仅仅是目标文件, 则其中的符号也需要出现在符号表中, 直接维护一个这样的符号表额外性能开销不大; 但是静态链接库的符号不需要暴露在符号表中, 并且比较独立, 相互依赖的情况较少, 维护这个表查询, 需要的开销???大吗? 可能需要链接大量的库的时候才会体现出来吧.</p>
<h2 id="mold"><a href="#mold" class="headerlink" title="mold"></a>mold</h2><p>看到一个更夸张的东西, <a target="_blank" rel="noopener" href="https://github.com/rui314/mold">mold</a>, 听起来就非常modern, 用C++20写的, 据说比lld快几倍, 仅仅比cp慢两倍. 16c32t下的速度:</p>
<img src="/2024/linkers/mold.png" class="" title="mold和lld以及gold的性能对比">

<p>原因除了使用更高效的数据结构和算法之外, 还有一个很粗暴的, 就是使用了更多的并行的组件:</p>
<img src="/2024/linkers/htop.gif" class="" title="lld(左)和mold(右)的处理器占用对比">

<p>对于如何使用更详细的选项可以参见<a target="_blank" rel="noopener" href="https://github.com/rui314/mold/blob/main/docs/mold.md">使用手册</a>, 下面我们根据他的<a target="_blank" rel="noopener" href="https://github.com/rui314/mold/blob/main/docs/design.md">设计手册</a>来看一下他们的design.</p>
<p>Mold和lld一样, 对于静态链接库的顺序没有任何的要求, 因为他们并不需要为了性能而这么折腾.</p>
<ul>
<li>mold会把过程分为前后两个部分, 前半部分就是符号解析和预处理, 后半部分主要是输出.</li>
<li>符号解析中String interning也是依靠哈希进行的, 也用类似的方法对常量字符串进行了合并.</li>
<li>对于动态链接库的GOT, 他会创建一个单独的条目来处理, 并且进行并行化.</li>
</ul>
<h3 id="Linker-Script"><a href="#Linker-Script" class="headerlink" title="Linker Script"></a>Linker Script</h3><p>连接器脚本是一个文档非常稀缺的一个东西, 它主要用于控制输入部分如何映射到输出部分以及输出的布局, 对于嵌入式编程比较有用. 我也是才知道又这个东西, 比如拿来链接的libc其实就是一个ASCII:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ file /usr/lib/x86_64-linux-gnu/libc.so</span><br><span class="line">/usr/lib/x86_64-linux-gnu/libc.so: ASCII text</span><br><span class="line">$ <span class="built_in">head</span> -n 100 /usr/lib/x86_64-linux-gnu/libc.so</span><br><span class="line">/* GNU ld script</span><br><span class="line">   Use the shared library, but some <span class="built_in">functions</span> are only <span class="keyword">in</span></span><br><span class="line">   the static library, so try that secondarily.  */</span><br><span class="line">OUTPUT_FORMAT(elf64-x86-64)</span><br><span class="line">GROUP ( /lib/x86_64-linux-gnu/libc.so.6 /usr/lib/x86_64-linux-gnu/libc_nonshared.a  AS_NEEDED ( /lib64/ld-linux-x86-64.so.2 ) )</span><br></pre></td></tr></table></figure>

<p>链接器脚本允许执行许多棘手的操作, 例如指定文件的确切布局, 在Section之间插入任意字节等. 大部分都是二进制编辑工具比如<code>objcopy</code>可以做的.</p>
<p>但是有一些是post-link editing tool无法做的</p>
<ol>
<li>mapping input sections to output sections</li>
<li>applying relocations.</li>
</ol>
<p>因此mold仅仅实现了指定输入输出section的映射, 以及根据映射进行重定位, 其他的都可以使用编辑工具来弥补.</p>
<h3 id="Concurrency-strategy"><a href="#Concurrency-strategy" class="headerlink" title="Concurrency strategy"></a>Concurrency strategy</h3><p>在大多数地方, mold采用数据并行. 例如一个循环中, 不同次数的循环之间没有数据和控制的依赖, 可以直接数据并行来分发给不同的执行单元.</p>
<p>但是上面是比较理想的状态, 在某一些时候, 循环时共享一些数据. 例如, 扫描重定位的循环打开符号表中符号的<code>requires GOT</code> or <code>requires PLT</code>. Symbol 是一个共享资源, mold将标志设置为atomic variable.</p>
<p>此外Mold还会使用map-reduce的模式, 比如计算输出的build id时候, 使用Merkle Tree分两层计算哈希.</p>
<p>Mold中的几个地方使用了并发的hashmap</p>
<h3 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h3><h4 id="Quick-Exit"><a href="#Quick-Exit" class="headerlink" title="Quick Exit"></a>Quick Exit</h4><p>不同于lld使用Amdahl’s law, mold认为, 要实现极限的性能(1s链接Chromium), 每一个部分都很重要. 如果映射了大量的文件, <code>_exit</code>退出的时间可能需要花费数百毫秒. 为此, 链接器组织成了两个进程, 第一个通过fork派生出来第二个, 第一个派生出来第二个, 第二个负责执行实际的任务, 再输出完目标文件之后, 第二个进程通知第一个进程去关闭, 然后第二个实际工作的进程自己去执行退出的系统调用和清理.</p>
<p>可以通过<code>--quick-exit</code>, <code>--no-quick-exit</code>来选择Use or do not use quick_exit to exit.</p>
<h4 id="覆盖现有文件"><a href="#覆盖现有文件" class="headerlink" title="覆盖现有文件"></a>覆盖现有文件</h4><p>至少在Linux上, 在创建新的大文件并使用<code>mmap</code>填充其内容时, 文件系统向新文件分配新块是性能瓶颈. 如果缓冲区缓存中已经有一个大文件, 则写入它比创建一个新文件并写入它要快得多.</p>
<p>根据这一观察, mold会覆盖现有的可执行文件(在增量编译时候). 基准测试表明, 创建2 GiB输出文件时可以节省300 ms(多大比例呢? 应该是一个还算比较高的比例?).</p>
<p>Linux不允许打开正在运行的可执行文件进行写入(作者说的, 表示怀疑). 如果无法打开输出文件, 则Mold会恢复到通常的方式.</p>
<h4 id="Build-Reproducibility"><a href="#Build-Reproducibility" class="headerlink" title="Build Reproducibility"></a>Build Reproducibility</h4><p>每次输出的二进制文件如果选项和输入相同, 则会产生相同的二进制. 便于调试.</p>
<h4 id="Build-Id的构造"><a href="#Build-Id的构造" class="headerlink" title="Build Id的构造"></a>Build Id的构造</h4><p><code>.build-id</code>是嵌入到输出文件的唯一ID, 通常是哈希文件的内容. 这是一个缓慢的步骤, mold通过将文件分割成小块, 为每个块计算SHA-1, 然后计算连接的SHA-1哈希值的SHA-1(即构建高度为2的默克尔树(Merkle Tree))来加快速度.</p>
<p>使用专用指令下, 哈希的计算速度为每个核心2 GiB&#x2F;s, 16c的处理器上, 2 GiB文件的build id仅仅需要60+ ms.</p>
<h4 id="Section-Garbage-Collection"><a href="#Section-Garbage-Collection" class="headerlink" title="Section Garbage Collection"></a>Section Garbage Collection</h4><p>ld.BFD, ld.gold, lld支持Section的垃圾回收. 即, 连接器运行标记-清除垃圾收集, 其中节是顶点, 重定位(即对另一个节的函数等符号的引用?)是边, 从<code>_start</code>开始, 标记每一个可以到达的边顶点, 也就是一个图上的遍历标记. 然后清楚不需要的Section.</p>
<p>Mold使用多线程来执行这个过程.</p>
<h4 id="COMDAT"><a href="#COMDAT" class="headerlink" title="COMDAT"></a>COMDAT</h4><h5 id="What-is-COMDAT-section"><a href="#What-is-COMDAT-section" class="headerlink" title="What is COMDAT section"></a>What is COMDAT section</h5><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/1834597/what-is-the-comdat-section-used-for">COMDAT section</a>是一个可以合并的段. COMDAT的目的是允许在多个目标文件中定义重复节. 如果在多个目标文件中定义了相同的符号, 链接器将报告错误. 例如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.cpp</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">add</span>(a, b); &#125;</span><br></pre></td></tr></table></figure>

<p>模板是在一个头文件中进行定义的, 然后可能多个文件都使用了这个模板, 都进行了实例化, 生成了目标文件.</p>
<p>如果按照一般的函数的处理方式, 多个使用了同一个模板, 同一个实例化的多个文件链接时候就会出现符号重定义的错误(因此一般的函数定义都是在CPP文件中, 而不是HPP文件中进行的).</p>
<p>因此我们可以看一下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -c -o a.o a.cpp</span><br><span class="line">readelf  -a a.o</span><br></pre></td></tr></table></figure>

<p>可以得到下面信息</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  [ 6] .text._Z3add[...] PROGBITS         0000000000000000  0000006b</span><br><span class="line">       0000000000000018  0000000000000000 AXG       0     0     1</span><br><span class="line">...</span><br><span class="line">COMDAT group section [    1] `.group&#x27; [_Z3addIiET_S0_S0_] contains 1 sections:</span><br><span class="line">   [Index]    Name</span><br><span class="line">   [    6]   .text._Z3addIiET_S0_S0_</span><br><span class="line">...</span><br><span class="line">Symbol table &#x27;.symtab&#x27; contains 6 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS a.cpp</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    2 .text</span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 .text._Z3addIiET[...]</span><br><span class="line">     4: 0000000000000000    35 FUNC    GLOBAL DEFAULT    2 _Z3fooii</span><br><span class="line">     5: 0000000000000000    24 FUNC    WEAK   DEFAULT    6 _Z3addIiET_S0_S0_</span><br></pre></td></tr></table></figure>

<p>可以看到, 这个加法函数单独放到了一个text段, 并且在COMDAT group section中标记这个段可以合并. 并且… 在符号表中, 这个实例化出来的函数, 也被标记成了弱符号(Weak Binding).</p>
<p>COMDAT合并有很多选项, 比如手动选择, 保证合并的段大小相同, 保证合并的段内容相同, 选择最大的等.</p>
<h5 id="Identical-Comdat-Folding"><a href="#Identical-Comdat-Folding" class="headerlink" title="Identical Comdat Folding"></a>Identical Comdat Folding</h5><p>链接器就是要干COMDAT段合并的任务, Identical Comdat Folding(ICM)就是合并相同的COMDAT的段. ICF合并两个或多个恰好具有相同内容和重定位的只读节. 链接器必须从较大的图中找到同构子图. 为此, Mold实现了一种新算法, Chromium上测量, mold比lld执行ICF的速度快5倍(5s-&gt;1s)</p>
<h4 id="Intel优化"><a href="#Intel优化" class="headerlink" title="Intel优化"></a>Intel优化</h4><p>使用Intel的one TBB(oneAPI Threading Building Blocks)的<code>parallel_for_each</code>和<code>concurrent_hash_map</code></p>
<p>同时TBB提供了<code>tbbmalloc</code>, 在多线程下, 比glibc的malloc更好, 但是jemalloc和mimalloc似乎比tbbmalloc拓展性更好.</p>
<h3 id="Rejected-ideas"><a href="#Rejected-ideas" class="headerlink" title="Rejected ideas"></a>Rejected ideas</h3><p>很有意思, 作者把这个也放上来了, 以免其他人提出来相同的ISSUE</p>
<h4 id="可变长度放到文件末尾-再完全确定文件布局之前进行拷贝"><a href="#可变长度放到文件末尾-再完全确定文件布局之前进行拷贝" class="headerlink" title="可变长度放到文件末尾, 再完全确定文件布局之前进行拷贝"></a>可变长度放到文件末尾, 再完全确定文件布局之前进行拷贝</h4><p>链接器必须消除重复的comdat部分, 因此在解析所有符号并消除重复的comdat之前, 无法计算常规部分的布局, 这需要几百毫秒. 可变长度部分的大小计算时间仅仅需要不到100 ms. 这个提升非常小(&lt;100ms?).</p>
<p>另一个更重要的原因是因为这个想法很有可能对链接器的整体性能产生负面影响. 如果我们在确定布局之前复制文件内容, 则在复制时无法对它们应用重定位, 因为符号地址尚不可用. 如果我们首先确定文件布局, 我们可以在复制时应用重定位, 可以获得很好的数据局部性.</p>
<h4 id="Incremental-linking"><a href="#Incremental-linking" class="headerlink" title="Incremental linking"></a>Incremental linking</h4><p>这个其实是我最感兴趣的.</p>
<p>这里说<code>GNU BFD and gold linkers support it.</code>, 但是我暂时没有so到相关的信息, 后面有时间再去看一下.</p>
<p>主要的原因有两个, 一个是太复杂, 正确性难以保证; 第二就是未必会带来性能提升.</p>
<p>首先就是这个增量链接会非常复杂. 首先要定位和比对修改文件中的变化, 这个就很复杂了, 之后面对不同的修改更繁琐. 比如更新的文件删除了一个符号, 需要重新搜索有没有这样的符号, 并且容易产生连锁反应; 类似的弱符号和COMDAT块也存在类似的问题. 并且修改的时候可能要修改每个用到的地址. 整个链接过程是牵一发动全身的. 因此尽管GOLD实现了增量链接, 为了正确性, 也很容易地退回到从头链接.</p>
<p>其次就是这个未必会带来性能提升, 比如对于文件修改的校对; 对于地址变化的符号还需要检查文件中的对应的位置进行修改; 如果内容有增加, 一般需要增加Padding, 以免影响后面的Section, 但是超出了Padding, 后面的Section中函数入口地址也会发生变化.</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>自己创建可执行文件的格式来加快链接过程. 兼容性不好保证, 而且ELF也没有那么差, 未必能带来性能提升.</p>
<p>inotify来监控文件更新更新后立马重新构建, 作者还在反驳, 说能监控的文件数量不多什么的, 我是无法理解这个… 太变态了, 每次保存都要重新构建, 而且大部分时候应该是失败的, 我没事就按保存不得把服务器卡死.</p>
<h3 id="Size-of-the-problem"><a href="#Size-of-the-problem" class="headerlink" title="Size of the problem"></a>Size of the problem</h3><p>果然, 较为大型的项目, 链接的过程可能非常大.</p>
<table>
<thead>
<tr>
<th>Data item</th>
<th>Number</th>
</tr>
</thead>
<tbody><tr>
<td>Object files</td>
<td>30,723</td>
</tr>
<tr>
<td>Public undefined symbols</td>
<td>1,428,149</td>
</tr>
<tr>
<td>Mergeable strings</td>
<td>1,579,996</td>
</tr>
<tr>
<td>Comdat groups</td>
<td>9,914,510</td>
</tr>
<tr>
<td>Regular sections¹</td>
<td>10,345,314</td>
</tr>
<tr>
<td>Public defined symbols</td>
<td>10,512,135</td>
</tr>
<tr>
<td>Symbols</td>
<td>23,953,607</td>
</tr>
<tr>
<td>Sections</td>
<td>27,543,225</td>
</tr>
<tr>
<td>Relocations against SHF_ALLOC sections</td>
<td>39,496,375</td>
</tr>
<tr>
<td>Relocations</td>
<td>62,024,719</td>
</tr>
</tbody></table>
<p>这么多的Symbols, 现在有点理解ld对于archive库的处理了…</p>
<h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><p>mold的作者还很详细地在design中介绍了链接器地发展历史和困难, archive文件的历史(SO文件历史还没写…)</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单调研了ld.bfd, ld.gold, lld和mold这几个链接器, 以及他们实现的功能和大概的性能. 尤其是后面三个如何进行的并行化操作.</p>
<p>一开始我以为并行链接是一个很难的事情, 后来发现除了最开始的默认的bfd, 其余的都可以并行链接.</p>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul>
<li>看一下ld的文章</li>
<li>看一下增量链接相关的文章</li>
<li>看一下Gold的更详细的设计</li>
<li>对比一下这四个编译器的速度和质量(文件大小, 性能等), 使用一些小型的项目, 比如gRPC和redis等.</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Survey/" rel="tag"># Survey</a>
              <a href="/tags/Compiler/" rel="tag"># Compiler</a>
              <a href="/tags/Linker/" rel="tag"># Linker</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/aphorisms/" rel="prev" title="计算机相关的英文的名言警句">
      <i class="fa fa-chevron-left"></i> 计算机相关的英文的名言警句
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/loaders/" rel="next" title="连接器的速度">
      连接器的速度 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-number">1.</span> <span class="nav-text">问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%80%BB%E6%98%AF%E8%BF%99%E4%B9%88%E6%85%A2"><span class="nav-number">1.1.</span> <span class="nav-text">为什么总是这么慢</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="nav-number">1.2.</span> <span class="nav-text">怎么解决</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GOLD"><span class="nav-number">2.</span> <span class="nav-text">GOLD</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%83%8C%E6%99%AF"><span class="nav-number">2.1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1"><span class="nav-number">2.2.</span> <span class="nav-text">设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B"><span class="nav-number">2.2.1.</span> <span class="nav-text">流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.2.2.</span> <span class="nav-text">多线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C"><span class="nav-number">2.2.3.</span> <span class="nav-text">C++</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Merge-Sections"><span class="nav-number">2.2.4.</span> <span class="nav-text">Merge Sections</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%A7%E8%83%BD"><span class="nav-number">2.2.5.</span> <span class="nav-text">性能</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Feature"><span class="nav-number">2.3.</span> <span class="nav-text">Feature</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ODR-One-Definition-Rule"><span class="nav-number">2.3.1.</span> <span class="nav-text">ODR(One Definition Rule)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%8B%E7%BC%A9Debug%E4%BF%A1%E6%81%AF"><span class="nav-number">2.3.2.</span> <span class="nav-text">压缩Debug信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%B2%E7%BB%8F%E5%AE%9E%E7%8E%B0%E4%BA%86%E7%9A%84%E6%9C%AA%E6%9D%A5"><span class="nav-number">2.3.3.</span> <span class="nav-text">已经实现了的未来</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#llvm%E7%9A%84lld"><span class="nav-number">3.</span> <span class="nav-text">llvm的lld</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87"><span class="nav-number">3.1.</span> <span class="nav-text">性能提升</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E5%85%B6%E4%BB%96%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">3.2.</span> <span class="nav-text">一些其他的特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Archive%E7%AC%A6%E5%8F%B7%E8%A7%A3%E6%9E%90%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="nav-number">3.3.</span> <span class="nav-text">Archive符号解析的顺序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mold"><span class="nav-number">4.</span> <span class="nav-text">mold</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Linker-Script"><span class="nav-number">4.1.</span> <span class="nav-text">Linker Script</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Concurrency-strategy"><span class="nav-number">4.2.</span> <span class="nav-text">Concurrency strategy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Details"><span class="nav-number">4.3.</span> <span class="nav-text">Details</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Quick-Exit"><span class="nav-number">4.3.1.</span> <span class="nav-text">Quick Exit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E7%8E%B0%E6%9C%89%E6%96%87%E4%BB%B6"><span class="nav-number">4.3.2.</span> <span class="nav-text">覆盖现有文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Build-Reproducibility"><span class="nav-number">4.3.3.</span> <span class="nav-text">Build Reproducibility</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Build-Id%E7%9A%84%E6%9E%84%E9%80%A0"><span class="nav-number">4.3.4.</span> <span class="nav-text">Build Id的构造</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Section-Garbage-Collection"><span class="nav-number">4.3.5.</span> <span class="nav-text">Section Garbage Collection</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#COMDAT"><span class="nav-number">4.3.6.</span> <span class="nav-text">COMDAT</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#What-is-COMDAT-section"><span class="nav-number">4.3.6.1.</span> <span class="nav-text">What is COMDAT section</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Identical-Comdat-Folding"><span class="nav-number">4.3.6.2.</span> <span class="nav-text">Identical Comdat Folding</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Intel%E4%BC%98%E5%8C%96"><span class="nav-number">4.3.7.</span> <span class="nav-text">Intel优化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rejected-ideas"><span class="nav-number">4.4.</span> <span class="nav-text">Rejected ideas</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E9%95%BF%E5%BA%A6%E6%94%BE%E5%88%B0%E6%96%87%E4%BB%B6%E6%9C%AB%E5%B0%BE-%E5%86%8D%E5%AE%8C%E5%85%A8%E7%A1%AE%E5%AE%9A%E6%96%87%E4%BB%B6%E5%B8%83%E5%B1%80%E4%B9%8B%E5%89%8D%E8%BF%9B%E8%A1%8C%E6%8B%B7%E8%B4%9D"><span class="nav-number">4.4.1.</span> <span class="nav-text">可变长度放到文件末尾, 再完全确定文件布局之前进行拷贝</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Incremental-linking"><span class="nav-number">4.4.2.</span> <span class="nav-text">Incremental linking</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">4.4.3.</span> <span class="nav-text">其他</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Size-of-the-problem"><span class="nav-number">4.5.</span> <span class="nav-text">Size of the problem</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96-1"><span class="nav-number">4.6.</span> <span class="nav-text">其他</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TODO"><span class="nav-number">6.</span> <span class="nav-text">TODO</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zombie12138</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zombie12138</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
