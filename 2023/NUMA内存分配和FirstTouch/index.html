<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zombie12138.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="最近看的NUMA绑核的这些比较多, 来盘点一下NUMA, 绑核, 以及NUMA系统中分配策略(First Touch), 以及遇到的一些坑.">
<meta property="og:type" content="article">
<meta property="og:title" content="NUMA内存分配, FirstTouch从接触到放弃">
<meta property="og:url" content="https://zombie12138.github.io/2023/NUMA%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8CFirstTouch/index.html">
<meta property="og:site_name" content="zombie&#39;s">
<meta property="og:description" content="最近看的NUMA绑核的这些比较多, 来盘点一下NUMA, 绑核, 以及NUMA系统中分配策略(First Touch), 以及遇到的一些坑.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zombie12138.github.io/2023/NUMA%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8CFirstTouch/kunpeng910-chipset-solution.png">
<meta property="og:image" content="https://zombie12138.github.io/2023/NUMA%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8CFirstTouch/kunpeng-numa.png">
<meta property="og:image" content="https://zombie12138.github.io/2023/NUMA%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8CFirstTouch/bind.png">
<meta property="article:published_time" content="2023-09-17T07:47:09.000Z">
<meta property="article:modified_time" content="2024-08-30T11:45:05.844Z">
<meta property="article:author" content="zombie12138">
<meta property="article:tag" content="Kunpeng">
<meta property="article:tag" content="HPC">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="Linux Programming">
<meta property="article:tag" content="C">
<meta property="article:tag" content="NUMA">
<meta property="article:tag" content="OpenMP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zombie12138.github.io/2023/NUMA%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8CFirstTouch/kunpeng910-chipset-solution.png">

<link rel="canonical" href="https://zombie12138.github.io/2023/NUMA%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8CFirstTouch/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>NUMA内存分配, FirstTouch从接触到放弃 | zombie's</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">zombie's</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zombie12138.github.io/2023/NUMA%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8CFirstTouch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zombie12138">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zombie's">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          NUMA内存分配, FirstTouch从接触到放弃
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-17 15:47:09" itemprop="dateCreated datePublished" datetime="2023-09-17T15:47:09+08:00">2023-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-08-30 19:45:05" itemprop="dateModified" datetime="2024-08-30T19:45:05+08:00">2024-08-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>最近看的NUMA绑核的这些比较多, 来盘点一下NUMA, 绑核, 以及NUMA系统中分配策略(First Touch), 以及遇到的一些坑.</p>
<span id="more"></span>

<p>实验在2Socket * 鲲鹏920-Server(一共128C 256G 4NUMA)进行, 操作系统<code>CentOS Linux release 7.9.2009 (AltArch)</code>, 内核版本<code>4.14.0-115.el7a.0.1.aarch64</code>, GCC 7.5.0, 开启了Page Size(65536, 64KB), (GNU libc) 2.17</p>
<h2 id="NUMA"><a href="#NUMA" class="headerlink" title="NUMA"></a>NUMA</h2><p>一般的个人电脑都是UMA(Uniform Memory Access), 不同的核心访问速度是相同的. 但是在服务器CPU中, 可能有多个CPU socket, CPU访问另一个处理器上的内存会更慢一些, 但是访问本地的内存会快一些， 这就是NUMA(Non-Uniform Memory Access). 当然, 为了提高单个处理器的带宽, 以满足不断增长的核心数的带宽需求, 也会把单个处理器上的核心分为几组, 每一组是一个NUMA Node. 核心自己所在的Node叫Local Node; 其他的Node就是Remote Node, 访存延迟和带宽都会更加受限; 有一些会把相同Socket不同的Node称为Neighbour Node， 速度介于两者之间.</p>
<p>比如下图的鲲鹏920-Server, 每一个SoC拥有两个CPU-Compute Die, 每一个CPU Compute Die拥有两对, 4个DDR控制器, 一个SoC有8个DDR控制器, 可以达到200GB&#x2F;s的带宽. 如图所示, 2个鲲鹏SoC就会有4个NUMA Node.</p>
<img src="/2023/NUMA%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8CFirstTouch/kunpeng910-chipset-solution.png" class="" title="kunpeng910-chipset-solution">

<img src="/2023/NUMA%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8CFirstTouch/kunpeng-numa.png" class="" title="kunpeng-numa">

<p>一些CPU也可以开启或者关闭NUMA, 甚至可以设置NUMA Node的数量. 可以使用<code>numactl -H</code>或者<code>lscpu</code>来查看是否存在NUMA, 比如在鲲鹏920上的输出如下, 里面还有不同NUMA Node的Distance</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ numactl -H</span><br><span class="line">available: 4 nodes (0-3)</span><br><span class="line">node 0 cpus: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31</span><br><span class="line">node 0 size: 64588 MB</span><br><span class="line">node 0 free: 54950 MB</span><br><span class="line">node 1 cpus: 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63</span><br><span class="line">node 1 size: 65465 MB</span><br><span class="line">node 1 free: 56654 MB</span><br><span class="line">node 2 cpus: 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95</span><br><span class="line">node 2 size: 65465 MB</span><br><span class="line">node 2 free: 47834 MB</span><br><span class="line">node 3 cpus: 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127</span><br><span class="line">node 3 size: 65463 MB</span><br><span class="line">node 3 free: 54275 MB</span><br><span class="line">node distances:</span><br><span class="line">node   0   1   2   3</span><br><span class="line">  0:  10  16  32  33</span><br><span class="line">  1:  16  10  25  32</span><br><span class="line">  2:  32  25  10  16</span><br><span class="line">  3:  33  32  16  10</span><br></pre></td></tr></table></figure>

<p>NUMA带来的好处就是可拓展性, 内存带宽跟随CPU核心数量上涨.</p>
<p>但是需要解决的问题也很多. 首先一个直观的就是, 程序很可能访问远端的内存, 这时候内存的速度就会下降很多. 另一方面, 可能会导致这种NUMA可能导致很多CPU争用一个内存控制器, 或者加大通讯压力等. 最后伪共享这些可能进一步加剧性能下降.</p>
<p>解决的办法也有很多, 可以通过NUMA感知的内存分配, 绑定核心(taskset, OpenMP proc bind, numactl等), 异步通讯, NUMA感知的算法等等来进行解决.</p>
<h2 id="Linux的NUMA内存分配策略"><a href="#Linux的NUMA内存分配策略" class="headerlink" title="Linux的NUMA内存分配策略"></a>Linux的NUMA内存分配策略</h2><p>说的比较乱, 最好还是去看<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/admin-guide/mm/numa_memory_policy.html">Linux Kernel Documentation</a></p>
<p>可以通过设置内核参数, 比如<code>zone_reclaim_mode</code>, 为0则内存不足的时候在远端的CPU分配内存; 也可以使用一些工具或者库, 比如<code>numactl</code>, 比如<code>numactl --interleave=all</code>; 还可以使用libnuma在编程中手动指定分配位置. </p>
<p><code>numactl</code>的绑核有下面几种类型: <code>default</code>在本地numa node上分配内存; <code>bind</code>指定在一系列特定的numa node上分配内存; <code>interleave</code>在一系列numa node上分配交错内存; <code>preferred</code>指定优先选取的node</p>
<p>但是Linux系统的分配策略不是在申请内存的时候就生效的. Linux内存分配策略就是<strong>First Touch</strong>, 第一次访问内存页(一般4K)的时候, 会产生缺页中断, 之后才会有真正的页面, 并且分配给一个物理页框。 听过一个笑话: 软件, 我就是申请内存, 我不用, 就是玩; OS, 我就标记一下, 但我不给你. 在NUMA的系统中, <strong>First Touch分配的内存页在第一次访问这个内存页的核心所在Node</strong>.  </p>
<h2 id="First-Touch测试向量加法"><a href="#First-Touch测试向量加法" class="headerlink" title="First Touch测试向量加法"></a>First Touch测试向量加法</h2><h3 id="一个线程来初始化"><a href="#一个线程来初始化" class="headerlink" title="一个线程来初始化"></a>一个线程来初始化</h3><p>来手动写一个OpenMP的加法.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numa.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">short</span> data_type;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> mem_size = <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024U</span>;</span><br><span class="line">    data_type *a = <span class="built_in">malloc</span>(mem_size);</span><br><span class="line">    data_type *b = <span class="built_in">malloc</span>(mem_size);</span><br><span class="line">    data_type *c = <span class="built_in">malloc</span>(mem_size);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> len = mem_size / <span class="built_in">sizeof</span>(data_type);</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel default(shared) num_threads(128)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> thread_id = <span class="built_in">omp_get_thread_num</span>();</span><br><span class="line">        <span class="type">int</span> cpu_id = <span class="built_in">sched_getcpu</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread %03d is running on CPU %03d\n&quot;</span>, thread_id, cpu_id);</span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> omp for</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            a[i] = <span class="number">3</span>;</span><br><span class="line">            b[i] = <span class="number">4</span>;</span><br><span class="line">            c[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> t1, t2;</span><br><span class="line">    <span class="built_in">gettimeofday</span>(&amp;t1, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#    <span class="keyword">pragma</span> omp parallel default(shared) num_threads(128)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> thread_id = <span class="built_in">omp_get_thread_num</span>();</span><br><span class="line">        <span class="type">int</span> cpu_id = <span class="built_in">sched_getcpu</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// get numa node id</span></span><br><span class="line">        <span class="type">int</span> status[<span class="number">1</span>];</span><br><span class="line">        status[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">        data_type *ptr = a + (len / <span class="number">128</span> * thread_id);</span><br><span class="line">        <span class="built_in">move_pages</span>(<span class="number">0</span> <span class="comment">/*self memory */</span>, <span class="number">1</span>, &amp;ptr,</span><br><span class="line">              <span class="literal">NULL</span>, status, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread %03d is running on CPU %03d, addr on node %d\n&quot;</span>, thread_id, cpu_id, status[<span class="number">0</span>]);</span><br><span class="line"><span class="meta">#       <span class="keyword">pragma</span> omp for</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">           c[i] = a[i] + b[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">gettimeofday</span>(&amp;t2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> deltat = (t2.tv_sec-t1.tv_sec) * <span class="number">1000000</span> + t2.tv_usec-t1.tv_usec;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Delt = %u \n&quot;</span>, deltat);</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// disable optimization</span></span><br><span class="line">    <span class="meta"># <span class="keyword">pragma</span> aomp parallel for default(shared) num_threads(128) reduction(+: sum)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; ++i) &#123;</span><br><span class="line">        sum += c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, sum);</span><br><span class="line">    <span class="built_in">free</span>(a);<span class="built_in">free</span>(b);<span class="built_in">free</span>(c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序先申请3个2GB的数组, 然后用<strong>一个</strong>OpenMP的线程进行初始化, 之后使用128个线程去做向量加法, 打印出来向量加法部分的时间. 最后的加法输出是很简单的方法来防止编译器优化.</p>
<p>输出OpenMP初始化和向量加法的线程和物理核心的映射关系, 同时还会输出该线程处理的数据内存第一个Page所在的NUMA Node.</p>
<p>OpenMP的for会把for循环任务按照循环变量切分成128份, 从第一份到最后一份依次分配给0~127号线程, 但是线程执行了在哪个CPU是调度决定的.</p>
<p>使用<code>gcc -o sum -O0 -pthread -lnuma -fopenmp sum.c</code>编译出来, 执行<code>./sum</code>. 注意, 上面的初始化是由一个线程完成的, 但是执行向量加法的操作是128的线程一起执行. 最终加法部分用时是<code>225930us</code></p>
<h3 id="128个线程来初始化"><a href="#128个线程来初始化" class="headerlink" title="128个线程来初始化"></a>128个线程来初始化</h3><p>按照我们之前的说的First Touch来分析, 由于初始化由一个线程执行, 该线程被分配至62号Core执行, 所以基本上全在1号Node. </p>
<p>但是如果使用128个线程来进行数组的初始化, 由于这些线程被分配到不同Node的Core, 内存页也会分不到不同的Node. 只需要把初始化的线程数改成128, 会来到<code>173465us</code>附近. 快了一倍.</p>
<p>很容易想到这是由于NUMA带来的结果. 向量加法是一个计算很稀疏的操作, 是memory bound的. 之前只能用到一个NUMA Node的内存, 现在可以用到所有的NUMA内存的带宽. </p>
<p>可以通过这样来统计一下每一段内存地起始地址在哪一个node中<code>./sum  | grep node | awk &#39;&#123;print $11&#125;&#39; | sort | uniq -c</code></p>
<p>得到还是有一些意外的, 在Node 1上最多.</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">27 0</span><br><span class="line">59 1</span><br><span class="line">10 2</span><br><span class="line">32 3</span><br></pre></td></tr></table></figure>

<p>如果严格按照First Touch分配, 理论上应该是在4个Node上均匀分布, 为什么分配的位置并不均匀呢…</p>
<p>首先想到的就是可能是OpenMP的Paralle For, 分配的粒度太细, 所以NUMA Node 0上的核心先进行了初始化. 于是赶紧查书, 也测试了一下, 确实是分成几个大段, 然后交给不同的Core分别运行.</p>
<p>其次想到, 是不是获取Node编号的api有问题, 换成了下面的API获取Node编号</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numaif.h&gt;</span></span></span><br><span class="line">data_type *ptr = a;</span><br><span class="line"><span class="type">int</span> node;</span><br><span class="line"><span class="built_in">get_mempolicy</span>(&amp;node, <span class="literal">NULL</span>, <span class="number">0</span>, (<span class="type">void</span> *)ptr, MPOL_F_NODE | MPOL_F_ADDR);</span><br></pre></td></tr></table></figure>

<p>但是上面的api也是一样效果.</p>
<p>想到问题可能是核心迁移造成的, 尝试绑核之后, 有所好转, 但是还是没有解决.</p>
<p>是不是Linux内存在分配时候在一段的前面打了奇怪的标签, 导致提前First Touch生效.<br>这个也不知道用什么来检测内存访问或者Page Fault. 想的是使用Perf来测一下Page Fault, 或者使用strace看一下system call.</p>
<h2 id="First-Touch的Debug"><a href="#First-Touch的Debug" class="headerlink" title="First Touch的Debug"></a>First Touch的Debug</h2><h3 id="Strace"><a href="#Strace" class="headerlink" title="Strace"></a>Strace</h3><p>先strace看一下调用(感觉没用, 就是爱看), trace的具体输出<a href="/2023/NUMA%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8CFirstTouch/strace_sum.txt" title="可以点击下载">可以点击下载</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ strace ./sum</span><br></pre></td></tr></table></figure>

<p>首先是调用<code>execve</code>执行sum可执行程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">execve(<span class="string">&quot;./sum&quot;</span>, [<span class="string">&quot;./sum&quot;</span>], <span class="number">0xffffea134380</span> <span class="comment">/* 44 vars */</span>) = <span class="number">0</span></span><br><span class="line"><span class="comment">// 查询堆顶地址</span></span><br><span class="line">brk(<span class="literal">NULL</span>)                               = <span class="number">0x2c0e0000</span></span><br></pre></td></tr></table></figure>

<p>后面是一堆大量的这些尝试搜索这些so的, 但是很多尝试都是不存在…</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openat(AT_FDCWD, <span class="string">&quot;/home/nscc-gz/guoych/local/spack/opt/spack/linux-centos7-aarch64/gcc-7.5.0/gcc-7.5.0-jgj56pzbhcc7c5ltarj6nrmqrkrzaoia/lib64/tls/aarch64/libnuma.so.1&quot;</span>, O_RDONLY|O_CLOEXEC) = <span class="number">-1</span> ENOENT (No such file or directory)</span><br><span class="line">newfstatat(AT_FDCWD, <span class="string">&quot;/home/nscc-gz/guoych/local/spack/opt/spack/linux-centos7-aarch64/gcc-7.5.0/gcc-7.5.0-jgj56pzbhcc7c5ltarj6nrmqrkrzaoia/lib64/tls/aarch64&quot;</span>, <span class="number">0xfffffe6aa250</span>, <span class="number">0</span>) = <span class="number">-1</span> ENOENT (No such file or directory)</span><br></pre></td></tr></table></figure>

<p>最后打开成功, 然后mmap的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">openat(AT_FDCWD, <span class="string">&quot;/etc/ld.so.cache&quot;</span>, O_RDONLY|O_CLOEXEC) = <span class="number">3</span></span><br><span class="line">fstat(<span class="number">3</span>, &#123;st_mode=S_IFREG|<span class="number">0644</span>, st_size=<span class="number">86270</span>, ...&#125;) = <span class="number">0</span></span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">86270</span>, PROT_READ, MAP_PRIVATE, <span class="number">3</span>, <span class="number">0</span>) = <span class="number">0x4000158f0000</span></span><br><span class="line">close(<span class="number">3</span>)                                = <span class="number">0</span></span><br><span class="line">openat(AT_FDCWD, <span class="string">&quot;/lib64/libnuma.so.1&quot;</span>, O_RDONLY|O_CLOEXEC) = <span class="number">3</span></span><br><span class="line">read(<span class="number">3</span>, <span class="string">&quot;\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0\267\0\1\0\0\00004\0\0\0\0\0\0&quot;</span>..., <span class="number">832</span>) = <span class="number">832</span></span><br><span class="line">fstat(<span class="number">3</span>, &#123;st_mode=S_IFREG|<span class="number">0755</span>, st_size=<span class="number">71208</span>, ...&#125;) = <span class="number">0</span></span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">149088</span>, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, <span class="number">3</span>, <span class="number">0</span>) = <span class="number">0x400015910000</span></span><br><span class="line">mmap(<span class="number">0x400015920000</span>, <span class="number">131072</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, <span class="number">3</span>, <span class="number">0</span>) = <span class="number">0x400015920000</span></span><br><span class="line">close(<span class="number">3</span>)                                = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>之后把一部分页设置成只读(有些是库, 比如<code>/lib64/libc.so.6</code>开头是<code>0x400015b40000</code>, 有一些没有找到出处)…</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mprotect(<span class="number">0x400015b40000</span>, <span class="number">65536</span>, PROT_READ) = <span class="number">0</span></span><br><span class="line">mprotect(<span class="number">0x400015bb0000</span>, <span class="number">65536</span>, PROT_READ) = <span class="number">0</span></span><br><span class="line">mprotect(<span class="number">0x400015b80000</span>, <span class="number">65536</span>, PROT_READ) = <span class="number">0</span></span><br><span class="line">mprotect(<span class="number">0x4000159b0000</span>, <span class="number">65536</span>, PROT_READ) = <span class="number">0</span></span><br><span class="line">mprotect(<span class="number">0x400015970000</span>, <span class="number">65536</span>, PROT_READ) = <span class="number">0</span></span><br><span class="line">mprotect(<span class="number">0x400015920000</span>, <span class="number">65536</span>, PROT_READ) = <span class="number">0</span></span><br><span class="line">mprotect(<span class="number">0x410000</span>, <span class="number">65536</span>, PROT_READ)    = <span class="number">0</span></span><br><span class="line">mprotect(<span class="number">0x4000158b0000</span>, <span class="number">65536</span>, PROT_READ) = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>把<code>/etc/ld.so.cache</code>关掉内存映射</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">munmap(<span class="number">0x4000158f0000</span>, <span class="number">86270</span>)           = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>之后一系列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置tid地址</span></span><br><span class="line">set_tid_address(<span class="number">0x4000158c6210</span>)         = <span class="number">951</span></span><br><span class="line"><span class="comment">// 告诉内核，鲁棒性列表的地址和大小，以便在线程异常终止时，内核可以自动扫描这个列表，并执行相应的清理操作</span></span><br><span class="line">set_robust_list(<span class="number">0x4000158c6220</span>, <span class="number">24</span>)     = <span class="number">0</span></span><br><span class="line"><span class="comment">// 设置signal的处理函数还有mask</span></span><br><span class="line">rt_sigaction(SIGRTMIN, &#123;sa_handler=<span class="number">0x4000159964a4</span>, sa_mask=[], sa_flags=SA_SIGINFO&#125;, <span class="literal">NULL</span>, <span class="number">8</span>) = <span class="number">0</span></span><br><span class="line">rt_sigaction(SIGRT_1, &#123;sa_handler=<span class="number">0x400015996584</span>, sa_mask=[], sa_flags=SA_RESTART|SA_SIGINFO&#125;, <span class="literal">NULL</span>, <span class="number">8</span>) = <span class="number">0</span></span><br><span class="line">rt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], <span class="literal">NULL</span>, <span class="number">8</span>) = <span class="number">0</span></span><br><span class="line"><span class="comment">// 获取对战大小</span></span><br><span class="line">getrlimit(RLIMIT_STACK, &#123;rlim_cur=RLIM64_INFINITY, rlim_max=RLIM64_INFINITY&#125;) = <span class="number">0</span></span><br><span class="line"><span class="comment">// 应该是查看cpu数量, 根据这个设置openmp线程数量</span></span><br><span class="line">openat(AT_FDCWD, <span class="string">&quot;/sys/devices/system/cpu&quot;</span>, O_RDONLY|O_NONBLOCK|O_CLOEXEC|O_DIRECTORY) = <span class="number">3</span></span><br><span class="line"><span class="comment">// 查询堆顶地址</span></span><br><span class="line">brk(<span class="literal">NULL</span>)                               = <span class="number">0xd380000</span></span><br><span class="line"><span class="comment">// 扩展堆内存相当于申请192KB内存?</span></span><br><span class="line">brk(<span class="number">0xd3b0000</span>)                          = <span class="number">0xd3b0000</span></span><br><span class="line"><span class="comment">// 读取目录内容???14个目录项... 不懂</span></span><br><span class="line">getdents64(<span class="number">3</span>, <span class="comment">/* 144 entries */</span>, <span class="number">32768</span>) = <span class="number">4520</span></span><br><span class="line">getdents64(<span class="number">3</span>, <span class="comment">/* 0 entries */</span>, <span class="number">32768</span>)   = <span class="number">0</span></span><br><span class="line">close(<span class="number">3</span>)                                = <span class="number">0</span></span><br><span class="line"><span class="comment">// 设置线程亲和性可以在所有的核心上执行</span></span><br><span class="line">sched_getaffinity(<span class="number">951</span>, <span class="number">16</span>, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>, <span class="number">36</span>, <span class="number">37</span>, <span class="number">38</span>, <span class="number">39</span>, <span class="number">40</span>, <span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>, <span class="number">44</span>, <span class="number">45</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">50</span>, <span class="number">51</span>, <span class="number">52</span>, <span class="number">53</span>, <span class="number">54</span>, <span class="number">55</span>, <span class="number">56</span>, <span class="number">57</span>, <span class="number">58</span>, <span class="number">59</span>, <span class="number">60</span>, <span class="number">61</span>, <span class="number">62</span>, <span class="number">63</span>, <span class="number">64</span>, <span class="number">65</span>, <span class="number">66</span>, <span class="number">67</span>, <span class="number">68</span>, <span class="number">69</span>, <span class="number">70</span>, <span class="number">71</span>, <span class="number">72</span>, <span class="number">73</span>, <span class="number">74</span>, <span class="number">75</span>, <span class="number">76</span>, <span class="number">77</span>, <span class="number">78</span>, <span class="number">79</span>, <span class="number">80</span>, <span class="number">81</span>, <span class="number">82</span>, <span class="number">83</span>, <span class="number">84</span>, <span class="number">85</span>, <span class="number">86</span>, <span class="number">87</span>, <span class="number">88</span>, <span class="number">89</span>, <span class="number">90</span>, <span class="number">91</span>, <span class="number">92</span>, <span class="number">93</span>, <span class="number">94</span>, <span class="number">95</span>, <span class="number">96</span>, <span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">102</span>, <span class="number">103</span>, <span class="number">104</span>, <span class="number">105</span>, <span class="number">106</span>, <span class="number">107</span>, <span class="number">108</span>, <span class="number">109</span>, <span class="number">110</span>, <span class="number">111</span>, <span class="number">112</span>, <span class="number">113</span>, <span class="number">114</span>, <span class="number">115</span>, <span class="number">116</span>, <span class="number">117</span>, <span class="number">118</span>, <span class="number">119</span>, <span class="number">120</span>, <span class="number">121</span>, <span class="number">122</span>, <span class="number">123</span>, <span class="number">124</span>, <span class="number">125</span>, <span class="number">126</span>, <span class="number">127</span>]) = <span class="number">16</span></span><br><span class="line"><span class="comment">// 检查进程状态</span></span><br><span class="line">openat(AT_FDCWD, <span class="string">&quot;/proc/self/status&quot;</span>, O_RDONLY) = <span class="number">3</span></span><br><span class="line">fstat(<span class="number">3</span>, &#123;st_mode=S_IFREG|<span class="number">0444</span>, st_size=<span class="number">0</span>, ...&#125;) = <span class="number">0</span></span><br><span class="line"><span class="comment">// 分配内存</span></span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">65536</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x4000158f0000</span></span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line">read(<span class="number">3</span>, <span class="string">&quot;Name:\tsum\nUmask:\t0002\nState:\tR (&quot;</span>..., <span class="number">1024</span>) = <span class="number">1024</span></span><br><span class="line">close(<span class="number">3</span>)                                = <span class="number">0</span></span><br><span class="line"><span class="comment">// free</span></span><br><span class="line">munmap(<span class="number">0x4000158f0000</span>, <span class="number">65536</span>)           = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">openat(AT_FDCWD, <span class="string">&quot;/sys/devices/system/node&quot;</span>, O_RDONLY|O_NONBLOCK|O_CLOEXEC|O_DIRECTORY) = <span class="number">3</span></span><br><span class="line"><span class="comment">// 猜测是读取Node的编号</span></span><br><span class="line">getdents64(<span class="number">3</span>, <span class="comment">/* 13 entries */</span>, <span class="number">32768</span>)  = <span class="number">408</span></span><br><span class="line"><span class="comment">// 读取Node2 meminfo</span></span><br><span class="line">openat(AT_FDCWD, <span class="string">&quot;/sys/devices/system/node/node2/meminfo&quot;</span>, O_RDONLY) = <span class="number">4</span></span><br><span class="line">fstat(<span class="number">4</span>, &#123;st_mode=S_IFREG|<span class="number">0444</span>, st_size=<span class="number">65536</span>, ...&#125;) = <span class="number">0</span></span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">65536</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x4000158f0000</span></span><br><span class="line">read(<span class="number">4</span>, <span class="string">&quot;Node 2 MemTotal:       67036992 &quot;</span>..., <span class="number">8192</span>) = <span class="number">1070</span></span><br><span class="line">read(<span class="number">4</span>, <span class="string">&quot;&quot;</span>, <span class="number">8192</span>)                       = <span class="number">0</span></span><br><span class="line">close(<span class="number">4</span>)                                = <span class="number">0</span></span><br><span class="line"><span class="comment">// 读取其他三个Node meminfo</span></span><br><span class="line"><span class="comment">// 之后free</span></span><br><span class="line">munmap(<span class="number">0x4000158f0000</span>, <span class="number">65536</span>)           = <span class="number">0</span></span><br><span class="line">getdents64(<span class="number">3</span>, <span class="comment">/* 0 entries */</span>, <span class="number">32768</span>)   = <span class="number">0</span></span><br><span class="line">close(<span class="number">3</span>)                                = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不是很懂, 重新设置了一下512*8个核心的亲和性, 然后又看了一眼CPU的核心数量</span></span><br><span class="line">sched_getaffinity(<span class="number">0</span>, <span class="number">512</span>, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>, <span class="number">36</span>, <span class="number">37</span>, <span class="number">38</span>, <span class="number">39</span>, <span class="number">40</span>, <span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>, <span class="number">44</span>, <span class="number">45</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">50</span>, <span class="number">51</span>, <span class="number">52</span>, <span class="number">53</span>, <span class="number">54</span>, <span class="number">55</span>, <span class="number">56</span>, <span class="number">57</span>, <span class="number">58</span>, <span class="number">59</span>, <span class="number">60</span>, <span class="number">61</span>, <span class="number">62</span>, <span class="number">63</span>, <span class="number">64</span>, <span class="number">65</span>, <span class="number">66</span>, <span class="number">67</span>, <span class="number">68</span>, <span class="number">69</span>, <span class="number">70</span>, <span class="number">71</span>, <span class="number">72</span>, <span class="number">73</span>, <span class="number">74</span>, <span class="number">75</span>, <span class="number">76</span>, <span class="number">77</span>, <span class="number">78</span>, <span class="number">79</span>, <span class="number">80</span>, <span class="number">81</span>, <span class="number">82</span>, <span class="number">83</span>, <span class="number">84</span>, <span class="number">85</span>, <span class="number">86</span>, <span class="number">87</span>, <span class="number">88</span>, <span class="number">89</span>, <span class="number">90</span>, <span class="number">91</span>, <span class="number">92</span>, <span class="number">93</span>, <span class="number">94</span>, <span class="number">95</span>, <span class="number">96</span>, <span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">102</span>, <span class="number">103</span>, <span class="number">104</span>, <span class="number">105</span>, <span class="number">106</span>, <span class="number">107</span>, <span class="number">108</span>, <span class="number">109</span>, <span class="number">110</span>, <span class="number">111</span>, <span class="number">112</span>, <span class="number">113</span>, <span class="number">114</span>, <span class="number">115</span>, <span class="number">116</span>, <span class="number">117</span>, <span class="number">118</span>, <span class="number">119</span>, <span class="number">120</span>, <span class="number">121</span>, <span class="number">122</span>, <span class="number">123</span>, <span class="number">124</span>, <span class="number">125</span>, <span class="number">126</span>, <span class="number">127</span>, ...]) = <span class="number">512</span></span><br><span class="line">openat(AT_FDCWD, <span class="string">&quot;/sys/devices/system/cpu&quot;</span>, O_RDONLY|O_NONBLOCK|O_CLOEXEC|O_DIRECTORY) = <span class="number">3</span></span><br><span class="line">getdents64(<span class="number">3</span>, <span class="comment">/* 144 entries */</span>, <span class="number">32768</span>) = <span class="number">4520</span></span><br><span class="line">getdents64(<span class="number">3</span>, <span class="comment">/* 0 entries */</span>, <span class="number">32768</span>)   = <span class="number">0</span></span><br><span class="line">close(<span class="number">3</span>)                                = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取了一下状态, 猜测这两次都是一个库函数调用的, 先设置亲和性然后检查</span></span><br><span class="line">openat(AT_FDCWD, <span class="string">&quot;/proc/self/status&quot;</span>, O_RDONLY) = <span class="number">3</span></span><br><span class="line">fstat(<span class="number">3</span>, &#123;st_mode=S_IFREG|<span class="number">0444</span>, st_size=<span class="number">0</span>, ...&#125;) = <span class="number">0</span></span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">65536</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x4000158f0000</span></span><br><span class="line">read(<span class="number">3</span>, <span class="string">&quot;Name:\tsum\nUmask:\t0002\nState:\tR (&quot;</span>..., <span class="number">1024</span>) = <span class="number">1024</span></span><br><span class="line">read(<span class="number">3</span>, <span class="string">&quot;switches:\t484\nnonvoluntary_ctxt_&quot;</span>..., <span class="number">1024</span>) = <span class="number">44</span></span><br><span class="line">read(<span class="number">3</span>, <span class="string">&quot;&quot;</span>, <span class="number">1024</span>)                       = <span class="number">0</span></span><br><span class="line">close(<span class="number">3</span>)                                = <span class="number">0</span></span><br><span class="line">munmap(<span class="number">0x4000158f0000</span>, <span class="number">65536</span>)           = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>malloc内存分配</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fstat(<span class="number">1</span>, &#123;st_mode=S_IFREG|<span class="number">0664</span>, st_size=<span class="number">0</span>, ...&#125;) = <span class="number">0</span></span><br><span class="line"><span class="comment">// 这个不知道是干嘛的, 猜测可能是和使用管道或者重定向时候, 多线程输出缓冲区相关的</span></span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">65536</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x4000158f0000</span></span><br><span class="line"><span class="comment">// 分配三个2GB的内存</span></span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">2147549184</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x400015bd0000</span></span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">2147549184</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x400095be0000</span></span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">2147549184</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x400115bf0000</span></span><br></pre></td></tr></table></figure>

<p>然后重复了127次下面的clone线程的操作, OpenMP还是蛮节约的, 主线程也担任一个, 每个分配2MB的空间(应该是栈)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">2162688</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x400195c00000</span></span><br><span class="line">mprotect(<span class="number">0x400195c00000</span>, <span class="number">65536</span>, PROT_NONE) = <span class="number">0</span></span><br><span class="line">clone(child_stack=<span class="number">0x400195e0ea90</span>, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=<span class="number">0x400195e0f250</span>, tls=<span class="number">0x400195e0f870</span>, child_tidptr=<span class="number">0x400195e0f250</span>) = <span class="number">952</span></span><br></pre></td></tr></table></figure>

<p>后面都是只有主线程的一些调用, 可能是和线程同步或者写入缓冲区相关</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个应该是唤醒线程的? 但是为什么只唤醒了125而不是127?</span></span><br><span class="line">futex(<span class="number">0xd380804</span>, FUTEX_WAKE_PRIVATE, <span class="number">2147483647</span>) = <span class="number">125</span></span><br><span class="line">getcpu([<span class="number">52</span>], <span class="literal">NULL</span>, <span class="literal">NULL</span>)                = <span class="number">0</span></span><br><span class="line"><span class="comment">// 这两个应该是同步的?</span></span><br><span class="line">futex(<span class="number">0xd380914</span>, FUTEX_WAIT_PRIVATE, <span class="number">0</span>, <span class="literal">NULL</span>) = <span class="number">0</span></span><br><span class="line">futex(<span class="number">0xd380914</span>, FUTEX_WAIT_PRIVATE, <span class="number">8</span>, <span class="literal">NULL</span>) = <span class="number">0</span></span><br><span class="line"><span class="comment">// 这个应该是唤醒线程的? 但是为什么更少了?</span></span><br><span class="line">futex(<span class="number">0xd380804</span>, FUTEX_WAKE_PRIVATE, <span class="number">2147483647</span>) = <span class="number">61</span></span><br><span class="line">getcpu([<span class="number">50</span>], <span class="literal">NULL</span>, <span class="literal">NULL</span>)                = <span class="number">0</span></span><br><span class="line">get_mempolicy([MPOL_PREFERRED], <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0x400095be0010</span>, MPOL_F_NODE|MPOL_F_ADDR) = <span class="number">0</span></span><br><span class="line">futex(<span class="number">0xd380914</span>, FUTEX_WAIT_PRIVATE, <span class="number">16</span>, <span class="literal">NULL</span>) = <span class="number">0</span></span><br><span class="line">futex(<span class="number">0xd380914</span>, FUTEX_WAKE_PRIVATE, <span class="number">2147483647</span>) = <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>最后free; 最后输出结果, 这个是使用了管道之后, 因此, 所有的printf都libc优化到了一次调用, 如果是普通的执行, 就会再上面的两段中调用主线程的write; 以及最后的推出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">munmap(<span class="number">0x400015bd0000</span>, <span class="number">2147549184</span>)      = <span class="number">0</span></span><br><span class="line">munmap(<span class="number">0x400095be0000</span>, <span class="number">2147549184</span>)      = <span class="number">0</span></span><br><span class="line">munmap(<span class="number">0x400115bf0000</span>, <span class="number">2147549184</span>)      = <span class="number">0</span></span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;n node 0\nThread 104 is running o&quot;</span>..., <span class="number">2427</span>) = <span class="number">2427</span></span><br><span class="line">exit_group(<span class="number">0</span>)                           = ?</span><br></pre></td></tr></table></figure>

<h3 id="Malloc中mmap的allign-up"><a href="#Malloc中mmap的allign-up" class="headerlink" title="Malloc中mmap的allign up"></a>Malloc中mmap的allign up</h3><p>可以注意到… Malloc的空间比2GB多了65536Byte, 64KB的空间, 并且所有的调用mmap的malloc都是这样. 在想是不是因为这65536malloc处理的时候触发了First touch…</p>
<p>但是打印了一下他们的ADDR, 发现地址是<code>0x400003820010</code>, 但是mmap得到的是<code>0x400003820000</code>. 说明前面少了16Byte, 但是还有65520大小的空间, 应该是对齐造成的资源浪费.</p>
<p>可以测试一下… 分别申请1MB的内存, 然后少申请0~32B的空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">33</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, -i);</span><br><span class="line">        <span class="built_in">malloc</span>(<span class="number">1024</span>*<span class="number">1024</span> - i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后可以使用<code>strace</code>来看申请的内存, 发现申请的内存是<code>1114112B</code>, 比<code>1MB</code>多<code>65536B</code>, 刚好是一个页面, 这是由于申请大小需要和页面对齐, 即使不对其, mmap后面其实也会帮用户对齐.<br>但是如果申请的内存减少到<code>1MB-24B</code>, 刚好申请的是<code>1MB</code>. 也就是说<code>malloc</code>申请的多了24B, 前面<code>16B</code>, 后面<code>8B</code>.</p>
<p>可以查看一下<a target="_blank" rel="noopener" href="https://codebrowser.dev/glibc/glibc/malloc/malloc.c.html#sysmalloc_mmap">源码</a>…</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">sysmalloc_mmap</span> <span class="params">(INTERNAL_SIZE_T nb, <span class="type">size_t</span> pagesize, <span class="type">int</span> extra_flags, mstate av)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">long</span> <span class="type">int</span> size;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Round up size to nearest page.  For mmapped chunks, the overhead is one</span></span><br><span class="line"><span class="comment">    SIZE_SZ unit larger than for normal chunks, because there is no</span></span><br><span class="line"><span class="comment">    following chunk whose prev_size field could be used.</span></span><br><span class="line"><span class="comment">    See the front_misalign handling below, for glibc there is no need for</span></span><br><span class="line"><span class="comment">    further alignments unless we have have high alignment.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="comment">// MALLOC_ALIGNMENT = (2 * (sizeof (size_t)) &lt; __alignof__ (long double) ? __alignof__ (long double) : 2 * (sizeof (size_t)))</span></span><br><span class="line">   <span class="comment">// CHUNK_HDR_SZ = (2 * (sizeof (size_t)))</span></span><br><span class="line">  <span class="keyword">if</span> (MALLOC_ALIGNMENT == CHUNK_HDR_SZ)</span><br><span class="line">    size = ALIGN_UP (nb + SIZE_SZ, pagesize);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    size = ALIGN_UP (nb + SIZE_SZ + MALLOC_ALIGN_MASK, pagesize);</span><br><span class="line">  <span class="comment">/* Don&#x27;t try if size wraps around 0.  */</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb))</span><br><span class="line">    <span class="keyword">return</span> MAP_FAILED;</span><br><span class="line">  <span class="type">char</span> *mm = (<span class="type">char</span> *) MMAP (<span class="number">0</span>, size,</span><br><span class="line">			    mtag_mmap_flags | PROT_READ | PROT_WRITE,</span><br><span class="line">			    extra_flags);</span><br><span class="line">  <span class="keyword">if</span> (mm == MAP_FAILED)</span><br><span class="line">    <span class="keyword">return</span> mm;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MAP_HUGETLB</span></span><br><span class="line">  <span class="keyword">if</span> (!(extra_flags &amp; MAP_HUGETLB))</span><br><span class="line">    madvise_thp (mm, size);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    The offset to the start of the mmapped region is stored in the prev_size</span></span><br><span class="line"><span class="comment">    field of the chunk.  This allows us to adjust returned start address to</span></span><br><span class="line"><span class="comment">    meet alignment requirements here and in memalign(), and still be able to</span></span><br><span class="line"><span class="comment">    compute proper address argument for later munmap in free() and realloc().</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  INTERNAL_SIZE_T front_misalign; <span class="comment">/* unusable bytes at front of new space */</span></span><br><span class="line">  <span class="keyword">if</span> (MALLOC_ALIGNMENT == CHUNK_HDR_SZ)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* For glibc, chunk2mem increases the address by CHUNK_HDR_SZ and</span></span><br><span class="line"><span class="comment">	 MALLOC_ALIGN_MASK is CHUNK_HDR_SZ-1.  Each mmap&#x27;ed area is page</span></span><br><span class="line"><span class="comment">	 aligned and therefore definitely MALLOC_ALIGN_MASK-aligned.  */</span></span><br><span class="line">      assert (((INTERNAL_SIZE_T) chunk2mem (mm) &amp; MALLOC_ALIGN_MASK) == <span class="number">0</span>);</span><br><span class="line">      front_misalign = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    front_misalign = (INTERNAL_SIZE_T) chunk2mem (mm) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">  mchunkptr p;                    <span class="comment">/* the allocated/returned chunk */</span></span><br><span class="line">  <span class="keyword">if</span> (front_misalign &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">ptrdiff_t</span> correction = MALLOC_ALIGNMENT - front_misalign;</span><br><span class="line">      p = (mchunkptr) (mm + correction);</span><br><span class="line">      set_prev_size (p, correction);</span><br><span class="line">      set_head (p, (size - correction) | IS_MMAPPED);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      p = (mchunkptr) mm;</span><br><span class="line">      set_prev_size (p, <span class="number">0</span>);</span><br><span class="line">      set_head (p, size | IS_MMAPPED);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* update statistics */</span></span><br><span class="line">  <span class="type">int</span> new = atomic_exchange_and_add (&amp;mp_.n_mmaps, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">  <span class="type">atomic_max</span> (&amp;mp_.max_n_mmaps, new);</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> sum;</span><br><span class="line">  sum = atomic_exchange_and_add (&amp;mp_.mmapped_mem, size) + size;</span><br><span class="line">  <span class="type">atomic_max</span> (&amp;mp_.max_mmapped_mem, sum);</span><br><span class="line">  check_chunk (av, p);</span><br><span class="line">  <span class="keyword">return</span> chunk2mem (p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到… 其实大小是allign up到pagesize. 当前环境<code>long double</code>的大小和align都是16B, <code>size_t</code>是8B, 所以应该是<code>size = ALIGN_UP (nb + SIZE_SZ, pagesize);</code>是16B, 但是事实却是24B.</p>
<p>猜测可能是版本的原因, 查看一下glibc的版本, 看到版本是<code>ldd (GNU libc) 2.17</code>, 于是查看<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/glibc/glibc-2.17/source/malloc/malloc.c#L2247">该版本的源码</a>, 发现这部分的内容是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">    size = (nb + SIZE_SZ + pagemask) &amp; ~pagemask;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    size = (nb + SIZE_SZ + MALLOC_ALIGN_MASK + pagemask) &amp; ~pagemask;</span><br></pre></td></tr></table></figure>

<p>就是24B刚好…</p>
<p>那么这24B是拿来干什么的呢, 继续看源码(不要看上面的啦)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = (mchunkptr)mm;</span><br><span class="line"><span class="comment">// #define set_head(p, s)       ((p)-&gt;size = (s))</span></span><br><span class="line">set_head(p, size|IS_MMAPPED);</span><br></pre></td></tr></table></figure>

<p>可以看到在刚mmap得到的地址前面(8<del>15B的地址), 存放了大小, 这也就是为什么free可以自动获得大小. 这个位置是8</del>15B的位置, 也就是我们malloc得到的地址的前面一点点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最后返回<code>chunck2mem</code>的地址, 就是16B的偏执<code>#define chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))</code>, 但是前面的8B和后面的8B都没有提到…在一开始看的版本<code>2.35</code>中是存放了0, 而现在再用的版本似乎没有使用…</p>
<p>然后…是<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/glibc/glibc-2.17/source/malloc/malloc.c#L3240"><code>_int_malloc</code></a>进行的调用…执行的是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="type">void</span> *p = sysmalloc(nb, av);</span><br><span class="line">  <span class="comment">// # define __builtin_expect(expr, val)   (expr)</span></span><br><span class="line">  <span class="comment">// 应该是0</span></span><br><span class="line">  <span class="keyword">if</span> (p != <span class="literal">NULL</span> &amp;&amp; __builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">  <span class="comment">// #define alloc_perturb(p, n) memset (p, (perturb_byte ^ 0xff) &amp; 0xff, n)</span></span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再往外就是内存管理的部分了…也就是说前后8B都没有使用…</p>
<p>我们来测试一下, 是否会如我们想的…打开看一下下面的c程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">void</span> *p = <span class="built_in">malloc</span>(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>, p);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到存放了长度<code>0x11000000000</code>还有一个bit是<code>IS_MMAPPED</code>标志位(0x0002)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x /20xh p-16</span><br><span class="line">0x400000210000:-0x0000  0x0000  0x0000  0x0000  0x0002  0x0011  0x0000  0x0000</span><br><span class="line">0x400000210010: 0x0000  0x0000  0x0000  0x0000  0x0000  0x0000  0x0000  0x0000</span><br><span class="line">0x400000210020: 0x0000  0x0000  0x0000  0x0000</span><br></pre></td></tr></table></figure>

<p>这个确实会影响一些, 比如一开始的时候, First Touch就已经触发了, 第一个页已经确定分配到了主线程所在的Node.</p>
<p>但是其他的按说不会影响太大…虽然每个线程开始的地方不是页面开始的地方, 但是理论上从前到后处理, 应该是不会变化的.</p>
<p>问题依然很难解决, 就先不看这个了…</p>
<h2 id="核心亲和性"><a href="#核心亲和性" class="headerlink" title="核心亲和性"></a>核心亲和性</h2><p>之前说过, 一种常见的应对NUMA的策略就是绑核. 我们设置一下打印出来多线程的核心位置, 然后编译<code>gcc -o print_cpu_id -O0 -pthread -lnuma -fopenmp print_cpu_id.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numaif.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numa.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">print_pid</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> threads[<span class="number">128</span>];</span><br><span class="line">    <span class="type">int</span> tid = (<span class="type">int</span>)arg;</span><br><span class="line">    <span class="comment">// sleep(1); </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1e8</span>; ++i);</span><br><span class="line">    <span class="type">int</span> cpu_id = sched_getcpu();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %03d is running on CPU %03d\n&quot;</span>, tid, cpu_id);</span><br><span class="line">    <span class="comment">// sleep(1); </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1e8</span>; ++i);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cpu_id2 = sched_getcpu();</span><br><span class="line">    <span class="keyword">if</span> (cpu_id != cpu_id2) &#123;</span><br><span class="line">        <span class="comment">// 迁移</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; %d \n&quot;</span>, cpu_id, cpu_id2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> num_threads = atoi(argv[<span class="number">1</span>]) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_threads; i++) &#123;</span><br><span class="line">        pthread_create(&amp;threads[i], <span class="literal">NULL</span>, print_pid, (<span class="type">void</span> *)(i + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init(<span class="literal">NULL</span>); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_threads; i++) &#123;</span><br><span class="line">        pthread_join(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后就可以玩啦, <code>./print_cpu_id 1</code>打印主线程, <code>./print_cpu_id 128</code>打印128个线程, 可以看到, 输出的结果非常多, <code>./print_cpu_id 128 | awk &#39;&#123;print $7&#125;&#39; | sort | uniq | wc</code>输出一共124个核心, 可能因为线程的迁移, 所以刚好有些线程在同一个线程, TOP上面看到的其实是128Core都用到了.</p>
<h3 id="taskset和numactl"><a href="#taskset和numactl" class="headerlink" title="taskset和numactl"></a>taskset和numactl</h3><p>taskset是一个最简单的绑核的工具. <code>taskset -c 1 ./print_cpu_id 1</code>打印出来核心在001, 多线程也一样<code> taskset -c 1 ./print_cpu_id 12</code>, 也可以<code>taskset -c 0-11 ./print_cpu_id 12</code></p>
<p>我们试一下strace一下<code>strace taskset -c 4 ./print_cpu_id 1</code>, 发现多了一个syscall, <code>sched_setaffinity(0, 256, [4, ...])     = 0</code>. 其实这个我们自己也可以做.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sched_setaffinity(<span class="number">0</span>, <span class="number">256</span>, [<span class="number">4</span>, ...])     = <span class="number">0</span></span><br><span class="line">execve(<span class="string">&quot;./print_cpu_id&quot;</span>, [<span class="string">&quot;./print_cpu_id&quot;</span>, <span class="string">&quot;1&quot;</span>], <span class="number">0xfffff40806c8</span> <span class="comment">/* 43 vars */</span>) = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>当然可以使用<code>numactl</code>设置亲和性, 比如<code>numactl -C coreid</code>.</p>
<p>此外numactl还可以设置内存分配策略, 比如<code>numactl --interleave=all</code>在不同的node之间分配内存. 拿来测试一下之前的向量加法<code>numactl --interleave=all ./sum  | grep node | awk &#39;&#123;print $11&#125;&#39; | sort | uniq -c</code>, 修改代码使用<strong>一个线程来初始化</strong>, 按照之前的FirstTouch, 应该是都在一个Node上, 但是结果如下, 内存分布在不同的node中, 效果非常好, 效果大概是内存分成了5个部分, 开头和结尾在一个Node, 中间三个段在一个Node. 用时是<code>180648us</code>, 虽然分布更均匀, 但是比128线程初始化来First Touch的效果稍微差一点, 猜测可能是过多访问远端节点造成的.</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">32 0</span><br><span class="line">32 1</span><br><span class="line">32 2</span><br><span class="line">32 3</span><br></pre></td></tr></table></figure>

<h3 id="手动设置亲和性"><a href="#手动设置亲和性" class="headerlink" title="手动设置亲和性"></a>手动设置亲和性</h3><p>如果手动调用这个效果也是一样, 不过可能会有额外的开销, 毕竟是在程序载入之后, 而taskset这种就像上面, 在execve之前就进行设置了亲和性</p>
<p>可以设置一个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 放到最开头</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bind_thread_to_core</span><span class="params">(<span class="type">int</span> core_id)</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpuset;</span><br><span class="line"></span><br><span class="line">    thread = pthread_self();</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;cpuset);</span><br><span class="line">    CPU_SET(core_id, &amp;cpuset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// or sched_setaffinity(0, sizeof(cpu_set_t), &amp;cpuset);</span></span><br><span class="line">    pthread_setaffinity_np(thread, <span class="keyword">sizeof</span>(<span class="type">cpu_set_t</span>), &amp;cpuset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后就可以直接<code>bind_thread_to_core(cpu_id)</code>来绑定了, 可以试一下, 这时候每个线程启动时候绑定一个核心就可以完成绑定核心.</p>
<h3 id="OpenMP和MPI绑定核心"><a href="#OpenMP和MPI绑定核心" class="headerlink" title="OpenMP和MPI绑定核心"></a>OpenMP和MPI绑定核心</h3><p>手动设置亲和性是代价比较高的, 而且很不方便, 但是如果是OpenMP和MPI程序来说taskset和numactl也不太起作用, 但是他们提供了自己的绑核机制.</p>
<h4 id="MPI"><a href="#MPI" class="headerlink" title="MPI"></a>MPI</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mpi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">    <span class="type">int</span> rank, size;</span><br><span class="line">    <span class="type">char</span> hostname[MPI_MAX_PROCESSOR_NAME];</span><br><span class="line">    <span class="type">int</span> hostname_len;</span><br><span class="line">    <span class="type">int</span> cpu_id = sched_getcpu();</span><br><span class="line"></span><br><span class="line">    MPI_Init(&amp;argc, &amp;argv);</span><br><span class="line">    MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);</span><br><span class="line">    MPI_Comm_size(MPI_COMM_WORLD, &amp;size);</span><br><span class="line">    MPI_Get_processor_name(hostname, &amp;hostname_len);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Rank %d (out of %d) is running on CPU %d on %s\n&quot;</span>, rank, size, cpu_id, hostname);</span><br><span class="line"></span><br><span class="line">    MPI_Finalize();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>mpicc -o mpi mpic.c</code>编译, 出来之后<code>mpirun -np 128 ./mpi | awk &#39;&#123;print $10&#125;&#39; | sort | uniq | wc</code>, 开启128个线程, 合并相同的cpuid, 然后发现有86个cpu.</p>
<p>mpi的绑核可以通过mpirun时候指定给出, <code>--bind-to &lt;policy&gt;</code>, 策略可以是none, hwthread, core, l1cache, l2cache, l3cache, socket, numa, board, 默认绑定到core上, 比如<code>mpirun -np 128 ./mpi | awk &#39;&#123;print $10&#125;&#39; | sort | uniq | wc</code>, 得到128个核心都有绑定线程, 但是映射是混乱的, 如果绑定l3, numa或者board就和之前一样了…</p>
<p>也可以和之前一样… <code>--report-bindings</code>设置打印绑定内容, <code>mpirun -np 4 --report-bindings --bind-to socket ./mpi</code>执行结果太长了不展示了…</p>
<p>可以尝试strace一下, 但是由于开启的这个进程只负责屏幕输出, 启动之类的, 所以需要追踪fork, 但是<code>strace -ff -o trace mpirun -np 4 --report-bindings --bind-to socket ./mpi</code>会出现段错误… 同时有太多进程, 会创建大量的<code>trace.$pid</code>, 因此可以创建一个warpper的脚本</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">LOGFILE=<span class="string">&quot;strace-<span class="subst">$(hostname)</span>.$$&quot;</span></span><br><span class="line"><span class="built_in">exec</span> strace -o<span class="string">&quot;<span class="variable">$LOGFILE</span>&quot;</span> /home/user/zombie/applications/neontest/mpi</span><br></pre></td></tr></table></figure>

<p>之后设置成可执行, 然后<code>mpirun -np 4 --report-bindings --bind-to socket ./mpi</code>, 看输出的stace, 依然没有<code>sched_setaffinity</code>, 猜测可能是创建之前就设置好了? 但是从<code>sched_getaffinity</code>结果来看, 其亲和性就被设置成第一个socket所有的core(0~63).</p>
<p>上面的这个是绑定策略, 但是线程和核心的映射依然是混乱的. 想要控制内存映射需要使用<code>--map-by &lt;arg&gt;</code>, 参数可以是slot, hwthread, core, L1cache, L2cache, L3cache, socket, numa, board, node, sequential, distance, and ppr… </p>
<p><code> mpirun -np 8 --bind-to core --map-by node ./mpi</code>理论上, 每个NUMA的线程ID分别为0 4, 1 5, 2 6, 3 7, 并且绑定每个核心. 但是这个还是段错误<code> signal 11 (Segmentation fault: address not mapped to object at address 0x2e392e312d6682)</code>感觉是libc版本的问题, 有时候地址甚至是0x14之类的… 先不管这个了…</p>
<h4 id="OpenMP"><a href="#OpenMP" class="headerlink" title="OpenMP"></a>OpenMP</h4><p>OpenMP的核心绑定其实也很简单… 首先OpenMP的线程其实也只是启动一次, 如果手动绑定线程的分配手动配置亲和性其实就可以了, 但是这个可能会影响调度(瞎说的), 并且也会有一点点的开销. 最好就是使用OpenMP的核心绑定.</p>
<p>OpenMP可以使用环境变量或者pragma来配置. MPI是轮询地把进程分配到<code>map-by</code>的集合上, 然后绑定到该集合上面的某个<code>bind-to</code>子集上, 其实是相当于OpenMP的Spread. OpenMP有spread, close, master, true, numa_domains, ll_caches. Spread就是类似MPI的轮询分配线程的方式, 但是每个线程绑定都是核心; Close是依次分配, 分配完一个区域再分配下一个区域; master就是使用主线程来执行. 每一个区域可以是线程, 核心, socket. 绑定的方式可以使用<code>OMP_PROC_BIND</code>指定, 区域可以使用<code>OMP_PLACES</code>来进行指定.</p>
<p>下图是一个4C8T的多线程, <code>OMP_PLACES</code>设置为<code>core</code>, 那么每个Core有两个线程, 使用<code>spread</code>和<code>close</code>其线程和核心的映射分布如下(方框表示OpenMP Place，数字表示线程ID):</p>
<img src="/2023/NUMA%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8CFirstTouch/bind.png" class="" title="OMP_PROC_BIND">

<p>如果想要更细粒度的绑定, 比如根据LLC之类的, 可以自己配置<code>OMP_PLACES</code>， 比如<code>OMP_PLACES=&quot;&#123;0&#125;,&#123;1&#125;,&#123;2&#125;,&#123;3&#125;&quot;</code>表示4个PLACE, 每一个地方是一个线程, <code>OMP_PLACES=&quot;&#123;0:2&#125;:32:8&quot;</code>表示, 开始是<code>0:2</code>, 0开始的2个线程, 就是0和1, 32表示有32个Places, 就是一共使用了64线程, 8表示间隔, 第一个PLACE是0和1, 第二个是8和9, 以此类推. 也可以组合使用, 比如<code>export OMP_PLACES=“&#123;0&#125;:4:1,&#123;78&#125;:4:1”</code>, 定义了8个Place, 分别是0, 1, 2, 3, 78, 79, 80, 81号线程.</p>
<h2 id="绑定核心后重新回到First-Touch出问题的地方"><a href="#绑定核心后重新回到First-Touch出问题的地方" class="headerlink" title="绑定核心后重新回到First Touch出问题的地方"></a>绑定核心后重新回到First Touch出问题的地方</h2><p>想到可能是再各种地方执行的… 所以… 可能就是很多再Node0上绑定的… 所以使用绑定之后</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ OMP_PROC_BIND=close ./sum  | grep node | awk <span class="string">&#x27;&#123;print $11&#125;&#x27;</span> | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c</span><br><span class="line">     50 0</span><br><span class="line">     32 1</span><br><span class="line">     32 2</span><br><span class="line">     14 3</span><br></pre></td></tr></table></figure>

<p>结果就是这样, 1 2号node始终32, 最后一个node少一些, 偶尔会是32…</p>
<p>而且, 由于每个Node处理自己最近的内存, 所以速度从之前的单个node<code>225930us</code>, 4个Node胡乱分布<code>173465us</code>, 到了现在的<code>91908us</code></p>
<p>其实一开始就想到这个了, 但是没有太注意, 理论上虽然glibc碰了一下内存, 但是也只是开头, 所以不同Node上的Page应该还是32…</p>
<p>仔细看一下<code>OMP_PLACES=cores OMP_PROC_BIND=close ./sum  | grep node | sort -k 2n</code>, 就会发现, 最后一部分的不符合预期(很多分配到了0号Node)</p>
<p>在想是不是glibc碰到了这个区域, 之前看malloc的部分代码, 但是也不能确定是在哪里碰到了这个代码, 只能确定开头的16B有写入了一些数据, 最后的8B也不知道, 不太像是glibc的问题.</p>
<p>尝试反过来初始化一下, 即每个线程都反过来从后往前初始化, 代码中初始化的下标改为<code>len - 1 - i</code>, 发现…开头又好多页面在Node0上… </p>
<p>不管了. 先排除malloc的作用, 把malloc换成mmap:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data_type *a = mmap(<span class="literal">NULL</span>, mem_size, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);<span class="comment">//malloc(mem_size);</span></span><br><span class="line">data_type *b = mmap(<span class="literal">NULL</span>, mem_size, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);<span class="comment">//malloc(mem_size);</span></span><br><span class="line">data_type *c = mmap(<span class="literal">NULL</span>, mem_size, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);<span class="comment">//malloc(mem_size);</span></span><br><span class="line">munmap(a, mem_size);</span><br><span class="line">munmap(b, mem_size);</span><br><span class="line">munmap(c, mem_size);</span><br></pre></td></tr></table></figure>

<p>重新绑核运行, 规规整整的, 和预想的一样. </p>
<h2 id="更诡异的事情"><a href="#更诡异的事情" class="headerlink" title="更诡异的事情"></a>更诡异的事情</h2><p>哪到底是glibc的哪些行为导致了first touch提前生效呢? 甚至开始怀疑First touch是不是以页面为单位的(虽然文档里这么讲的). </p>
<p>写一个pthread的程序, 在Node3上执行主线程, mmap分配内存, 然后去触碰中间一个页面的开头的区域, 然后其他的线程在Node0上去触碰所有的内存, 查看一下内存的分布情况(其实仅仅使用一个线程应该也是可以的).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numaif.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bind_thread_to_core</span><span class="params">(<span class="type">int</span> core_id)</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpuset;</span><br><span class="line"></span><br><span class="line">    thread = pthread_self();</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;cpuset);</span><br><span class="line">    CPU_SET(core_id, &amp;cpuset);</span><br><span class="line"></span><br><span class="line">    sched_setaffinity(<span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">cpu_set_t</span>), &amp;cpuset);</span><br><span class="line">    <span class="comment">//pthread_setaffinity_np(thread, sizeof(cpu_set_t), &amp;cpuset);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 65536 * 1024</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> LEN 67108864</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">init</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    bind_thread_to_core(<span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> *s = (<span class="type">char</span> *)arg;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">long</span> i = <span class="number">0</span>; i &lt; LEN; ++i) &#123;</span><br><span class="line">        s[i] = <span class="number">0xff</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    bind_thread_to_core(<span class="number">127</span>);</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="type">char</span> *c = mmap(<span class="literal">NULL</span>, LEN, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">65536</span>; ++i)</span><br><span class="line">        c[i + <span class="number">65536</span> * <span class="number">512</span>] = <span class="number">0xcc</span>;   <span class="comment">// touch 513rd page</span></span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;thread, <span class="literal">NULL</span>, init, (<span class="type">void</span> *)c);</span><br><span class="line">    pthread_join(thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; ++i) &#123;</span><br><span class="line">        <span class="type">char</span> *ptr = c + i * <span class="number">65536</span>;</span><br><span class="line">        <span class="type">int</span> node;</span><br><span class="line">        get_mempolicy(&amp;node, <span class="literal">NULL</span>, <span class="number">0</span>, (<span class="type">void</span> *)ptr, MPOL_F_NODE | MPOL_F_ADDR);</span><br><span class="line">        <span class="keyword">if</span> (node) &#123;</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    munmap(c, LEN);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果就是只有512是在3号Node上… 是以页面为单位… First touch没问题</p>
<p>诡异的事情来了, 我就要把锅扣到malloc时候, 突然想到, 再看一下源码, 重新打开源码, 找了一圈也没有找到… 改成malloc, 变成了0, 512, 513是在Node3上, 这个和我们预想的完全一样…</p>
<p>问题到底在哪里? 已知:</p>
<ul>
<li>malloc过程中只碰前16B</li>
<li>mmap完全不碰</li>
<li>first touch是以页面为单位的</li>
<li>malloc&#x2F;mmap + pthread在两个线程时候完全正常.</li>
<li><strong>malloc + opemmp开头和结尾会被分配到主线程所在node</strong></li>
<li>mmap + openmp开头和结尾是正常的</li>
</ul>
<p>那就是malloc+openmp会出现一些怪东西, 触发了First touch. 是OpenMP+glibc出现了这个问题?</p>
<p>这就watch一下这一段内存, 之前不这样做主要原因是以为是malloc自己的锅, 那这样想要监视这段地址, 就需要调试glibc, mmap拿到地址之后监视内存访问. 但是从之前的分析, malloc本身是正常的, 那就可以malloc之后再监视最后的一段内存…</p>
<h3 id="GDB调试"><a href="#GDB调试" class="headerlink" title="GDB调试"></a>GDB调试</h3><p>使用gdb进行调试…</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b 18</span><br><span class="line">r</span><br><span class="line">watch *(char [16]*)0x400080330000</span><br><span class="line">c</span><br></pre></td></tr></table></figure>

<p>试了试watch和rwatch(按说读取不会触发)都没看到访问最后的那一个页面… 如果设置成65536速度又会非常非常慢…</p>
<p>想到一些通过设置权限来捕捉内存访问, 那就把a整个数组全都设置成不可读, 不可写<code>call mprotect(0x400000340000, 2147483648, 0)</code></p>
<p>但是continue捕捉到的是a再赋值的时候…</p>
<p>这就非常奇怪了…为什么会在赋值语句才访问到… 但是被其他人碰过, <code>call mprotect(0x400080340000, 65536, 0)</code>看一下最后一个页面, 发现<code>info threads</code>显示就是第128个线程访问的… 这也…</p>
<p>后面rw是正常, malloc不会rw访问后面的这些应用…</p>
<p>那为什么first touch会这么异常…如果是一些类似<code>mprotect</code>这些也不会影响, 而且我的里面没有看到有这个… 真的好怪异… 除了OpenMP+malloc似乎就没有其他的有问题… 当然我这里都是只检查了开头的地址, 可能有一些其他的异常的没有发现</p>
<h3 id="诡异到放弃"><a href="#诡异到放弃" class="headerlink" title="诡异到放弃"></a>诡异到放弃</h3><p>手动模拟malloc进行mmap分配也会观察到类似的malloc相同特征, 本来规规整整的First touch, 突然内存尾部多了好多分配在主节点的内存…</p>
<p>并且… 如果使用mmap分配规整的一大块内存, 使用128线程来初始化是正常的, 但是使用4线程初始化也会出现类似更加严重的现象</p>
<p>所以怀疑是内存分配策略做了一些优化之类的… 测试到发现… 似乎… 更诡异了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numaif.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bind_thread_to_core</span><span class="params">(<span class="type">int</span> core_id)</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpuset;</span><br><span class="line"></span><br><span class="line">    thread = pthread_self();</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;cpuset);</span><br><span class="line">    CPU_SET(core_id, &amp;cpuset);</span><br><span class="line"></span><br><span class="line">    sched_setaffinity(<span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">cpu_set_t</span>), &amp;cpuset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 * 1024 * 1024 * 1024</span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> LEN = <span class="number">4294967296UL</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">init</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    bind_thread_to_core(<span class="number">69</span>);</span><br><span class="line">    <span class="type">char</span> *s = (<span class="type">char</span> *)arg;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">long</span> i = <span class="number">0</span>; i &lt; LEN; ++i) &#123;</span><br><span class="line">        s[i] = <span class="number">0xff</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    bind_thread_to_core(<span class="number">127</span>);</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="type">char</span> *c = <span class="built_in">malloc</span>(LEN);</span><br><span class="line">    <span class="comment">//char *c = mmap(NULL, LEN, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>*<span class="number">65536</span>; ++i) c[<span class="number">16</span> + i + <span class="number">65536</span> * <span class="number">512</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">65536</span>*<span class="number">16</span>; ++i) c[<span class="number">16</span> + i + <span class="number">65536</span> * (<span class="number">512</span> + <span class="number">19</span>)] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;thread, <span class="literal">NULL</span>, &amp;init, (<span class="type">void</span> *)c);</span><br><span class="line">    ret = pthread_join(thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; LEN/<span class="number">65536</span>; ++i) &#123;</span><br><span class="line">        <span class="type">char</span> *ptr = c + i * <span class="number">65536</span>;</span><br><span class="line">        <span class="type">int</span> node;</span><br><span class="line">        get_mempolicy(&amp;node, <span class="literal">NULL</span>, <span class="number">0</span>, (<span class="type">void</span> *)ptr, MPOL_F_NODE | MPOL_F_ADDR);</span><br><span class="line">        <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, i, node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(c);</span><br><span class="line"> <span class="comment">//   munmap(c, LEN);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码… 最后是检测有没有什么是在Node0, 输出很诡异…</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">65486 0</span><br><span class="line">65488 0</span><br><span class="line">65489 0</span><br><span class="line">65493 0</span><br><span class="line">65498 0</span><br><span class="line">65499 0</span><br><span class="line">65502 0</span><br><span class="line">65527 0</span><br><span class="line">65531 0</span><br><span class="line">65532 0</span><br><span class="line">65534 0</span><br><span class="line">65535 0</span><br></pre></td></tr></table></figure>

<p>突然意识到… 这两个… 主线程first touch的是在Node3, 另一个线程是在Node2, 但是出现了若干段Node0上的空间… 已经彻底无法理解这个过程了…(其实后来感觉是硬件数据预取的问题?)</p>
<h3 id="libnuma"><a href="#libnuma" class="headerlink" title="libnuma"></a>libnuma</h3><p>我想要控制NUMA的内存分配位置, 首先就是可以使用一些libnuma提供的接口, 比如<code>numa_alloc_onnode</code>来指定分配的节点, <code>numa_free</code>来释放.</p>
<p>让笨蛋ChatGPT来帮我写一段代码, 两个线程分别来处理一个vector, 求得加法总和之后加到一起. ChatGPT写出来如下代码(当然一开始也是全都是Bug, 而且也只能看看怎么使用):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numa.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SIZE = <span class="number">100000000</span>; <span class="comment">// 100 million</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> HALF = SIZE / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sum</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; data, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">long</span> <span class="type">long</span>&amp; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">        result += data[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size, <span class="type">int</span> node)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;newing &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">void</span>* ret = <span class="built_in">numa_alloc_onnode</span>(size, node);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Custom delete operator</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* memory, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> size)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Delete &quot;</span> &lt;&lt; size &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">numa_free</span>(memory, size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">numa_available</span>() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;NUMA not supported&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt;* data = <span class="built_in">new</span>(<span class="number">0</span>) std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(SIZE, <span class="number">1</span>);</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> result1 = <span class="number">0</span>, result2 = <span class="number">0</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;starting threads&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([=, &amp;result1] &#123; numa_run_on_node(<span class="number">0</span>); sum(*data, <span class="number">0</span>, HALF, result1); &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([=, &amp;result2] &#123; numa_run_on_node(<span class="number">1</span>); sum(*data, HALF, SIZE, result2); &#125;)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;waiting threads&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; result1 + result2 &lt;&lt; std::endl;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(data, <span class="keyword">sizeof</span>(std::vector&lt;<span class="type">int</span>&gt;))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译使用<code>g++ -o numa -pthread -lnuma -O0 -std=c++11 numa.cpp</code></p>
<p>GPT写的这个笨蛋代码, 是内存感知分配了, 但是分配了个皮(vector类本身的24Byte), vector的内存分配还是默认策略, 而且vector还在一个地方(vector持有的空间其实也是), 线程却在在两个Node中间. <strong>基本上就是看个怎么用, 是NUMA感知的负优化</strong>.</p>
<p>不过大概知道怎么用就好了…</p>
<h2 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h2><p>总是写得非常长, 又臭又长, 其实本来想写一下如何让vector不初始化来使用, 以及如何调用私有函数这些… </p>
<p>但是写的时候介绍背景就已经很长了, 想先写First Touch来配置内存分布, 然后Bind Core的优化.</p>
<p>就这样写到一半的时候发现First touch不是总是起作用, 猜测是glibc再内存做了一些标注; 之后查看syscall什么也没发现, 但是发现mmap申请的空间其实是比malloc更大的; 然后又去看malloc的mmap的实现, 发现只会影响第一个页面.</p>
<p>后面的页面NUMA的分配更诡异…用gdb监视内存读写, 或者改内存页权限, 都什么也没发现, 最后彻底无法理解…也没有找到相关的问题讨论或者文档说明… 感觉需要去用一些其他的Debug的方式来监控Linux页面实际的分配过程…</p>
<p>整个过程感觉很是难受… 其实还是怀疑是数据预取的问题? 题外话: 之前使用lmbench测试访存的延迟, 得到内存工作集在128KB(2倍的L1缓存)时候, 延迟才下降到L2. 但是后来更新了系统, Ubuntu22, 就是正常的(64KB出现延迟的突变). 两者BIOS都开启了数据预取, 这个我现在想不到是什么原因导致的, 并且感觉可能和现在的状况有关. 但是现在新版本系统没有测试我的这些代码, 就这样吧…</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="NUMA-1"><a href="#NUMA-1" class="headerlink" title="NUMA"></a>NUMA</h3><ul>
<li>Xia, Jing, et al. “Kunpeng 920: The first 7-nm chiplet-based 64-core arm soc for cloud services.” IEEE Micro 41.5 (2021): 67-75.</li>
<li>Liu, Xu, and John Mellor-Crummey. “A tool to analyze the performance of multithreaded programs on NUMA architectures.” ACM Sigplan Notices 49.8 (2014): 259-272.</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/343661117">原来cpu是这样访问内存的-cpu的NUMA浅析</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_16099276/6902805">numa架构 numa架构设计要点</a></li>
<li><a target="_blank" rel="noopener" href="https://sukihiro.cn/2020/03/25/numa-os-part2/">操作系统对NUMA支持情况：OS部分</a></li>
<li><a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/v5.10/admin-guide/mm/numaperf.html">The Linux kernel user’s and administrator’s guide - NUMA Locality</a></li>
<li><a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/admin-guide/mm/numa_memory_policy.html">NUMA Memory Policy - Linux Kernel Documentation</a></li>
<li><a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man3/numa.3.html">NUMA3 - man7</a></li>
<li><a target="_blank" rel="noopener" href="https://queue.acm.org/detail.cfm?id=2513149">NUMA (Non-Uniform Memory Access): An Overview - ACM queue</a></li>
<li><a target="_blank" rel="noopener" href="https://linux.die.net/man/8/numad">NUMAD(8) - Linux man page</a></li>
</ul>
<h3 id="First-Touch"><a href="#First-Touch" class="headerlink" title="First Touch"></a>First Touch</h3><ul>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/49105427/c-numa-optimization">C++ NUMA Optimization - StackOverflow</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/72055210/openmp-array-initialization-impact">OpenMP array initialization impact - StackOverflow</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/11576670/in-an-openmp-parallel-code-would-there-be-any-benefit-for-memset-to-be-run-in-p">In an OpenMP parallel code, would there be any benefit for memset to be run in parallel? - StackOverflow</a></li>
<li>Trindade, Rafael Gauna, João VF Lima, and Andrea Schwertner Charão. “A Memory Affinity Analysis of Scientific Applications on NUMA Platforms.” 2021 International Symposium on Computer Architecture and High Performance Computing Workshops (SBAC-PADW). IEEE, 2021.</li>
</ul>
<h3 id="Malloc"><a href="#Malloc" class="headerlink" title="Malloc"></a>Malloc</h3><ul>
<li><a target="_blank" rel="noopener" href="https://www.gnu.org/software/libc/manual/html_node/The-GNU-Allocator.html">3.2.2 The GNU Allocator - GNU</a></li>
<li><a target="_blank" rel="noopener" href="https://sourceware.org/glibc/wiki/MallocInternals">Overview of Malloc - glibc wiki</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/pdv5MMUQ9ACpeCpyGnxb1Q">2万字|30张图带你领略glibc内存管理精髓 - 高性能架构探索</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/163401620?utm_id=0">分析 Glibc 中的malloc&#x2F;free 实现 - 知乎</a></li>
<li><a target="_blank" rel="noopener" href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/?blogsub=confirming#subscribe-blog%E3%80%82">Understanding glibc malloc - sploitfun</a>(<a target="_blank" rel="noopener" href="https://blog.csdn.net/maokelong95/article/details/51989081">中文</a>)</li>
<li><a target="_blank" rel="noopener" href="https://csstormq.github.io/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AF%87%E4%B9%8B%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%EF%BC%884%EF%BC%89%EF%BC%9A%E5%86%8D%E6%8E%A2%20mmap">计算机系统篇之虚拟内存（4）：再探 mmap - csstormq’s github page</a></li>
<li><a target="_blank" rel="noopener" href="https://codebrowser.dev/glibc/glibc/malloc/malloc.c.html">Malloc Source Code - Codebrowser</a></li>
<li><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/glibc/glibc-2.17/source/malloc/malloc.c">Malloc Source Code 2.17 - Bootlin</a></li>
</ul>
<h3 id="Bind-Core"><a href="#Bind-Core" class="headerlink" title="Bind Core"></a>Bind Core</h3><ul>
<li><a target="_blank" rel="noopener" href="https://lab.cs.tsinghua.edu.cn/hpc/doc/faq/binding/#openmp">进程绑定 - 高性能计算导论实验文档</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ibm.com/docs/en/xl-fortran-linux/16.1.0?topic=openmp-omp-proc-bind">OMP_PROC_BIND - IBM Documentation</a></li>
<li><a target="_blank" rel="noopener" href="https://hpc-wiki.info/hpc/Binding/Pinning">Binding&#x2F;Pinning - HPCWiki</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/cd/E60778_01/html/E60751/goztg.html">OMP_PLACES and OMP_PROC_BIND - Oracle</a></li>
<li><a target="_blank" rel="noopener" href="https://www.openmp.org/wp-content/uploads/SC18-BoothTalks-vanderPas.pdf">How To Befriend NUMA - OpenMP</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.rwth-aachen.de/itc-events/files/2021/02/13-openmp-CT-NUMA.pdf">Programming OpenMP - NUMA - Christian Terboven</a></li>
</ul>
<h3 id="libnuma-1"><a href="#libnuma-1" class="headerlink" title="libnuma"></a>libnuma</h3><ul>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/7986903/can-i-get-the-numa-node-from-a-pointer-address-in-c-on-linux">StackOverflow - Can I get the NUMA node from a pointer address (in C on Linux)?</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/memory/new/operator_delete">Cppreference - operator delete, operator delete[]</a>.</li>
</ul>

    </div>

    
    
    

      <div> <div class="my-post-copyright">
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

  <!-- JS库 sweetalert 可修改路径 -->
  <script type="text/javascript" src="http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js"></script>
  <script src="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js"></script>
  <link rel="stylesheet" type="text/css" href="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css">

  <p><span>本文标题:</span>NUMA内存分配, FirstTouch从接触到放弃</a></p>
  <p><span>文章作者:</span></a></p>
  <p><span>发布时间:</span>2023年09月17日 - 15:47:09</p>
  <p><span>最后更新:</span>2024年08月30日 - 19:45:05</p>
  <p><span>原始链接:</span><a href="/2023/NUMA%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8CFirstTouch/" title="NUMA内存分配, FirstTouch从接触到放弃">https://zombie12138.github.io/2023/NUMA%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8CFirstTouch/</a>
    <span class="copy-path"  title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="https://zombie12138.github.io/2023/NUMA%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8CFirstTouch/"  aria-label="复制成功！"></i></span>
  </p>
  <p><span>特殊声明:</span>本篇文章由我个人在空闲时间独立制作。所有观点、看法及内容均为个人意见，不代表任何组织或公司的立场。</p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p>
</div>
<script>
    var clipboard = new Clipboard('.fa-clipboard');
    clipboard.on('success', $(function(){
      $(".fa-clipboard").click(function(){
        swal({
          title: "",
          text: '复制成功',
          html: false,
          timer: 500,
          showConfirmButton: false
        });
      });
    }));
</script>
 </div>

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Kunpeng/" rel="tag"># Kunpeng</a>
              <a href="/tags/HPC/" rel="tag"># HPC</a>
              <a href="/tags/C/" rel="tag"># C++</a>
              <a href="/tags/Linux-Programming/" rel="tag"># Linux Programming</a>
              <a href="/tags/C/" rel="tag"># C</a>
              <a href="/tags/NUMA/" rel="tag"># NUMA</a>
              <a href="/tags/OpenMP/" rel="tag"># OpenMP</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/Peterson%E7%AE%97%E6%B3%95%E4%B9%8B%E4%B8%80--%E5%9C%A8So%E4%B8%AD%E4%BA%92%E6%96%A5%E8%AE%BF%E9%97%AE%E5%8F%98%E9%87%8F/" rel="prev" title="Peterson算法之一--在So中互斥访问变量">
      <i class="fa fa-chevron-left"></i> Peterson算法之一--在So中互斥访问变量
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/%E4%B8%8D%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84Vector-resize-%E5%8A%AB%E6%8C%81%E7%B1%BB%E7%A7%81%E6%9C%89%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-Folly%E5%BA%93/" rel="next" title="不调用构造函数的Vector resize | 劫持类私有成员函数 | Folly库">
      不调用构造函数的Vector resize | 劫持类私有成员函数 | Folly库 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#NUMA"><span class="nav-number">1.</span> <span class="nav-text">NUMA</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux%E7%9A%84NUMA%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="nav-number">2.</span> <span class="nav-text">Linux的NUMA内存分配策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#First-Touch%E6%B5%8B%E8%AF%95%E5%90%91%E9%87%8F%E5%8A%A0%E6%B3%95"><span class="nav-number">3.</span> <span class="nav-text">First Touch测试向量加法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%9D%A5%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">3.1.</span> <span class="nav-text">一个线程来初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#128%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%9D%A5%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">3.2.</span> <span class="nav-text">128个线程来初始化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#First-Touch%E7%9A%84Debug"><span class="nav-number">4.</span> <span class="nav-text">First Touch的Debug</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Strace"><span class="nav-number">4.1.</span> <span class="nav-text">Strace</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Malloc%E4%B8%ADmmap%E7%9A%84allign-up"><span class="nav-number">4.2.</span> <span class="nav-text">Malloc中mmap的allign up</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E4%BA%B2%E5%92%8C%E6%80%A7"><span class="nav-number">5.</span> <span class="nav-text">核心亲和性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#taskset%E5%92%8Cnumactl"><span class="nav-number">5.1.</span> <span class="nav-text">taskset和numactl</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%8B%E5%8A%A8%E8%AE%BE%E7%BD%AE%E4%BA%B2%E5%92%8C%E6%80%A7"><span class="nav-number">5.2.</span> <span class="nav-text">手动设置亲和性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OpenMP%E5%92%8CMPI%E7%BB%91%E5%AE%9A%E6%A0%B8%E5%BF%83"><span class="nav-number">5.3.</span> <span class="nav-text">OpenMP和MPI绑定核心</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MPI"><span class="nav-number">5.3.1.</span> <span class="nav-text">MPI</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#OpenMP"><span class="nav-number">5.3.2.</span> <span class="nav-text">OpenMP</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%91%E5%AE%9A%E6%A0%B8%E5%BF%83%E5%90%8E%E9%87%8D%E6%96%B0%E5%9B%9E%E5%88%B0First-Touch%E5%87%BA%E9%97%AE%E9%A2%98%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="nav-number">6.</span> <span class="nav-text">绑定核心后重新回到First Touch出问题的地方</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E8%AF%A1%E5%BC%82%E7%9A%84%E4%BA%8B%E6%83%85"><span class="nav-number">7.</span> <span class="nav-text">更诡异的事情</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GDB%E8%B0%83%E8%AF%95"><span class="nav-number">7.1.</span> <span class="nav-text">GDB调试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%A1%E5%BC%82%E5%88%B0%E6%94%BE%E5%BC%83"><span class="nav-number">7.2.</span> <span class="nav-text">诡异到放弃</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#libnuma"><span class="nav-number">7.3.</span> <span class="nav-text">libnuma</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%90%E6%A7%BD"><span class="nav-number">8.</span> <span class="nav-text">吐槽</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">9.</span> <span class="nav-text">参考</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#NUMA-1"><span class="nav-number">9.1.</span> <span class="nav-text">NUMA</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#First-Touch"><span class="nav-number">9.2.</span> <span class="nav-text">First Touch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Malloc"><span class="nav-number">9.3.</span> <span class="nav-text">Malloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bind-Core"><span class="nav-number">9.4.</span> <span class="nav-text">Bind Core</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#libnuma-1"><span class="nav-number">9.5.</span> <span class="nav-text">libnuma</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zombie12138</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zombie12138</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
